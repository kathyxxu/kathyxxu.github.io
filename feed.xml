<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kathyxxu Blog</title>
    <description>前端工程师 | 这里是 @Kathyxxu 的个人博客，记录点点滴滴。</description>
    <link>http://kathyxxu.github.io/</link>
    <atom:link href="http://kathyxxu.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 25 Nov 2015 08:58:16 +0800</pubDate>
    <lastBuildDate>Wed, 25 Nov 2015 08:58:16 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>javascript创建对象</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;1.创建对象&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var person = new Object();
person.name = &#39;kathy&#39;;
person.age = 25;
person.job = &#39;frontend&#39;;
person.sayName = function(){
    alert(this.name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br /&gt;
使用同一个接口创建很多对象，会产生大量重复代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.工厂模式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function createPerson(name,age,job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    }
    return o;
}
var p1 = createPerson(&#39;kathy&#39;,25,&#39;frontend&#39;);
var p2 = createPerson(&#39;jack&#39;,24,&#39;backend&#39;);
p1.sayName(); //&#39;kathy&#39;
p2.sayName(); //&#39;jack&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;用函数来封装以特定接口创建对象的细节&lt;br /&gt;
&lt;strong&gt;优点：&lt;/strong&gt;&lt;br /&gt;
解决了创建多个相似对象的问题&lt;br /&gt;
&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br /&gt;
没有解决对象识别的问题（怎样知道一个对象的类型）&lt;br /&gt;
不能用new&lt;br /&gt;
函数重复定义 （p1.sayName == p2.sayName）  false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3.构造函数模式：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    };
}
var p1 = new Person(&#39;kathy&#39;,25,&#39;frontend&#39;);
var p2 = new Person(&#39;jack&#39;,24,&#39;backend&#39;);
p1.sayName(); //&#39;kathy&#39;
p2.sayName(); //&#39;jack&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;区别工厂模式：&lt;/strong&gt;&lt;br /&gt;
1、没有显式的创建对象&lt;br /&gt;
2、直接将属性和方法赋给了this对象&lt;br /&gt;
3、没有return语句&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;创建Person的新实例4步骤：&lt;/strong&gt;&lt;br /&gt;
1、创建一个新的对象&lt;br /&gt;
2、将构造函数的作用域赋给新对象（this指针就指向了这个新对象）&lt;br /&gt;
3、执行构造函数中的代码（为这个新对象添加属性）&lt;br /&gt;
4、返回新对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;3.1对象识别问题&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function Func() {};      // 定义一个空函数
var obj1 = new Func();   // 使用new操作符，借助Func函数，创建了一个对象
var obj2 = new Func;     // 函数也可以没有括号，但仍将调用该函数
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;js的语法可真是飘逸，该如何理解呢？&lt;br /&gt;
其实，上面的写法可以写成以下等价形式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Func() {}; 
var obj = {};
Func.call(obj);   // 将obj对象作为this指针调用Func函数
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;br /&gt;
解决了对象识别问题，可以将它的实例表示为一种特定的类型。&lt;br /&gt;
&lt;code&gt;alert(p1.constructor == Person);  //true&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(p2.constructor == Person);  //true&lt;/code&gt;&lt;br /&gt;
p1和p2分别保存着Person的一个不同的实例，都有一个constructor属性，指向Person&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;对象的&lt;strong&gt;constructor&lt;/strong&gt;属性最初是用来表示对象类型的。&lt;br /&gt;
对于检测对象类型，还是&lt;strong&gt;instanceof&lt;/strong&gt;可靠些，&lt;br /&gt;
&lt;code&gt;alert(p1 instanceof Object);  //true&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(p1 instanceof Person);  //true&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(p2 instanceof Object);  //true&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(p2 instanceof Person);  //true&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;3.2构造函数的三种调用方式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//当做构造函数使用，构造函数与其他函数唯一区别：调用方式不同，用new
var person = new Person(&#39;kathy&#39;,25,&#39;student&#39;);
person.sayName();

//作为普通函数调用
Person(&#39;Jack&#39;,30,&#39;doctor&#39;);
window.sayName();

//在另一个对象的作用域中调用
var o = new Object();
Person.call(o,&#39;Cate&#39;,27,&#39;nurse&#39;);
o.sayName();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;当在全局作用域中调用一个函数，this对象总是指向Global对象（在浏览器中就是window对象）&lt;br /&gt;
可以使用call(),apply()在某个特殊对象的作用域中调用Person()函数。这里是在o的作用域中调用的，调用后o就拥有了所有属性和sayName()方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-5&quot;&gt;3.3构造函数的问题&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// 函数是对象，每定义一个函数，也就是实例化了一个对象。
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = new Function(&quot; alert(this.name)&quot;); //与申明函数在逻辑上是等价的
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br /&gt;
每个方法都要在每个实例上重新创建一遍，p1和p2都有一个名为sayName()的方法，但是不是同一个Function的实例，却拥有同样的功能。&lt;br /&gt;
&lt;code&gt;alert(p1.sayName() == p2.sayName()); //false&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;br /&gt;
把函数定义移到构造函数外部：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName;
}

function sayName(){
    alert(this.name);
}

var p1 = new Person(&#39;kathy&#39;,25,&#39;student&#39;)
var p2 = new Person(&#39;cgg&#39;,24,&#39;programmer&#39;);

p1.sayName();
p2.sayName();
alert(p1.constructor == Person);  //true
alert(p2.constructor == Person);  //true
alert(p1 instanceof Object);  //true
alert(p1 instanceof Person);  //true
alert(p2 instanceof Object);  //true
alert(p2 instanceof Person);  //true
alert(p1.sayName == p2.sayName);  //true
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;p1和p2对象共享在全局作用域中定义的一个sayName()函数。&lt;br /&gt;
&lt;strong&gt;问题：&lt;/strong&gt;&lt;br /&gt;
让全局作用域有点名不副实，&lt;br /&gt;
如果对象需要定义多个方法，就要定义多个全局函数，那么这个自定义的应用类型就毫无封装性可言了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-6&quot;&gt;4.原型模式&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;原型好处：可以让所有对象实例共享它所包含的属性和方法，&lt;br /&gt;
不必再构造函数中定义对象信息，可以直接添加到原型对象中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}

Person.prototype.name = &#39;kathy&#39;;
Person.prototype.age = 25;
Person.prototype.job = &#39;student&#39;;
Person.prototype.sayName = function(){
    alert(this.name);
};

var p1 = new Person();
p1.sayName();  //&#39;kathy&#39;

var p2 = new Person();
p2.sayName();  //&#39;kathy&#39;

alert(p1.sayName == p2.sayName);  //true
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;将Person的所有属性都直接添加到Person的prototype属性中，构造函数变成了空函数。&lt;br /&gt;
仍可调用构造函数创建一个新对象，新对象还会具有相同的属性和方法，p1和p2访问的是同一组属性和同一个sayName()函数；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-7&quot;&gt;4.1理解原型：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;../../../../imgPost/2015-11-20/p1.png&quot; alt=&quot;&amp;quot;理解原型&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一旦创建函数，就为该函数创建一个prototype属性。&lt;br /&gt;
默认情况，所有prototype属性自动获得一个constructor属性，至于其他方法，都是从Object继承而来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Person.prototype 指向原型对象&lt;/li&gt;
  &lt;li&gt;Person.prototype.constructor 又指回Person&lt;/li&gt;
  &lt;li&gt;Person的实例person1,person2包含一个内部属性&lt;code&gt;_proto_&lt;/code&gt;，指向Person.prototype，他们与构造函数没有直接的关系&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()，是通过查找对象属性的过程来实现的。&lt;br /&gt;
查找顺序：&lt;strong&gt;先对象本身，后原型属性&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}

Person.prototype.name = &#39;kathy&#39;;
Person.prototype.age = 25;
Person.prototype.job = &#39;frontend&#39;;
Person.prototype.sayName = function(){
    alert(this.name);
}

var p1 = new Person();
var p2 = new Person();

p1.name = &#39;xuxuan&#39;;
alert(p1.name); //&#39;xuxuan&#39;
alert(p2.name); //&#39;kathy&#39;

p1.name = null;
alert(p1.name); // null

delete p1.name;
alert(p1.name); // &#39;kathy&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;当为对象实例添加一个属性时，会屏蔽原型对象中同名属性，添加的这个属性会阻止我们访问原型中的那个属性，但不会修改那个值。&lt;br /&gt;
即使将这个属性设置为&lt;code&gt;null&lt;/code&gt;，也只会在实例中设置这个属性，不会恢复其指向原型的链接。&lt;br /&gt;
不过可以通过&lt;code&gt;delete&lt;/code&gt;操作符完成删除实例的属性，从而能重新访问原型中的属性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;isprototypeofhasownpropertyin&quot;&gt;4.2 isPrototypeOf、hasOwnProperty、in属性&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}

Person.prototype.name = &#39;kathy&#39;;
Person.prototype.age = 25;
Person.prototype.job = &#39;student&#39;;
Person.prototype.sayName = function(){
    alert(this.name);
}

var p1 = new Person();
var p2 = new Person();

alert(Person.prototype.isPrototypeOf(p1));  //true
alert(Person.prototype.isPrototypeOf(p2));  //true

alert(p1.hasOwnProperty(&#39;name&#39;));  //fasle
p1.name = &#39;xuxuan&#39;
alert(p1.name);  //&#39;xuxuan&#39;
alert(p1.hasOwnProperty(&#39;name&#39;));  //true

alert(p2.name);  //&#39;kathy&#39;
alert(p2.hasOwnProperty(&#39;name&#39;));  //false

delete p1.name;
alert(p1.name);  //&#39;kathy&#39;
alert(p1.hasOwnProperty(&#39;name&#39;));  //false
alert(&#39;name&#39; in p1);  //true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上段代码图解如下：&lt;br /&gt;
&lt;img src=&quot;../../../../imgPost/2015-11-20/p2.png&quot; alt=&quot;&amp;quot;理解原型&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结如下：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;isPrototypeOf&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;obj1.isPrototypeOf(obj2);&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;用来判断指定对象obj1是否存在于另一个对象obj2的原型链中，是则返回true，否则返回false。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hasOwnProperty&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;obj.hasOwnProperty(&#39;name&#39;);&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;只检测&lt;strong&gt;对象本身的属性&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;in&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;&#39;name&#39; in obj&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;检测&lt;strong&gt;对象本身的属性&lt;/strong&gt;或&lt;strong&gt;原型链的属性&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hasPrototypeProperty(自定义方法)&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;hasPrototypeProperty(obj,&#39;name&#39;)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;‘name’属性只存在于&lt;strong&gt;原型链的属性&lt;/strong&gt;，而不存在于对象本身的属性&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;function hasPrototypeProperty(object,name){
    return !object.hasOwnProperty(name) &amp;amp;&amp;amp; (name in object);
}

function Person(){}

Person.prototype.name = &#39;kathy&#39;;
Person.prototype.age = 25;
Person.prototype.job = &#39;student&#39;;
Person.prototype.sayName = function(){
     alert(this.name);
}

var p = new Person();
alert(hasPrototypeProperty(p,&#39;name&#39;)); //true

p.name = &#39;xuxuan&#39;;
alert(hasPrototypeProperty(p,&#39;name&#39;)); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-8&quot;&gt;4.3更简单的原型语法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}

Person.prototype = {
    name : &#39;kathy&#39;,
    age : 25 ,
    job : &#39;student&#39;,
    sayName : function(){
        alert(this.name);
    }
};

var person = new Person();
alert(person instanceof Object); //true
alert(person instanceof Person); //true
alert(person.constructor == Object); //true
alert(person.constructor == Person); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了从视觉上更好的封装原型，用一个包含所有属性和方法的对象字面量来重写整个原型对象；&lt;br /&gt;
每创建一个函数，同时也会创建它的prototype对象，其会自动获得constructor属性；&lt;br /&gt;
&lt;code&gt;Person.prototype = {...};&lt;/code&gt;本质上重写了默认的prototype属性，constructor属性不再指向Person，而指向Object函数。&lt;br /&gt;
如果写成&lt;code&gt;Person.prototype.name=&quot;kathy&quot;;...&lt;/code&gt;，constructor还是Person；&lt;br /&gt;
如果&lt;code&gt;var person = new Person();&lt;/code&gt; 写在&lt;code&gt;Person.prototype = {...}&lt;/code&gt;之前，这个对象的constructor还是Person;&lt;br /&gt;
尽管instanceof还能返回正确结果，但是通过constructor无法确定对象类型；&lt;br /&gt;
如果constructor的值真的很重要，可以特意将它设置回适当的值：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Person.prototype = {
     constructor : Person,
     name : &#39;kathy&#39;,
     ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-9&quot;&gt;4.4原型的动态性&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}
var person = new Person();
Person.prototype.sayHi = function(){
     alert(&quot;hi&quot;);
}
person.sayHi(); //hi
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;在原型中查找值得过程是一次搜索，因此对原型做的任何修改能立刻从实例中反映出来（先创建实例，后修改原型也如此）；&lt;br /&gt;
&lt;strong&gt;原因：&lt;/strong&gt; 实例与原型的松散链接关系，调用person.sayHi()时，先在实例中搜sayHi属性，没有，搜原型；实例与原型之间连接是一个&lt;strong&gt;指针&lt;/strong&gt;，而非一个副本，就可以在原型中找到sayHi属性并返回。&lt;br /&gt;
&lt;strong&gt;注意：&lt;/strong&gt; 如果重写整个原型对象，情况就不一样了。因为调用构造函数会为实例添加一个指向最初原型的&lt;code&gt;_proto_&lt;/code&gt;指针，而把原型修改为另外一个对象，就等于切断了构造函数与最初原型之间的联系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;../../../../imgPost/2015-11-20/p3.png&quot; alt=&quot;&amp;quot;理解原型&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可看出：重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../imgPost/2015-11-20/p4.png&quot; alt=&quot;&amp;quot;理解原型&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;4.5原型对象的问题&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、省略了为构造函数传递初始化参数这一环节，所有实例默认情况下取得相同的属性值，一定不便&lt;br /&gt;
2、共享，对函数非常适合；包含基本值的属性，也还好；引用类型的属性，问题突出&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}

Person.prototype = {
    constructor : Person,
    name : &#39;kathy&#39;,
    age : 25 ,
    job : &#39;student&#39;,
    sayName : function(){
        alert(this.name);
    },
    friends:[&quot;Jack&quot;,&quot;Cate&quot;]
};

var person1 = new Person();
var person2 = new Person();
person1.friends.push(&quot;Van&quot;);

alert(person1.friends); //&#39;Jack,Cate,Van&#39;
alert(person2.friends); //&#39;Jack,Cate,Van&#39;
alert(person1.friends == person2.friends); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-11&quot;&gt;5.组合使用构造函数模式和原型模式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = [&quot;Jack&quot;,&quot;Cate&quot;];
}

Person.prototype = {
    constructor : Person,
    sayName : function(){
        alert(this.name);
    }
};

var person1 = new Person(&#39;kathy&#39;,25,&#39;frontend&#39;);
var person2 = new Person(&#39;jack&#39;,24,&#39;backend&#39;);
person1.friends.push(&quot;Van&quot;);

alert(person1.friends); //&#39;Jack,Cate,Van&#39;
alert(person2.friends); //&#39;Jack,Cate&#39;
alert(person1.friends == person2.friends); //false
alert(person1.sayName == person2.sayName); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;构造函数 –&amp;gt; 定义实例属性&lt;br /&gt;
原型模式 –&amp;gt; 定义方法和共享的属性&lt;br /&gt;
&lt;strong&gt;优点：&lt;/strong&gt; 节省内存，向构造函数传参&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-12&quot;&gt;6.动态原型模式：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;

    if(typeof this.sayName != &#39;function&#39;){
        //只在sayName方法不存在时，才添加到原型中；只会在初次调用构造函数才执行，此后原型已完成初始化
        Person.prototype.sayName = function(){
            alert(this.name);
        };
    }
}

var person = new Person(&#39;kathy&#39;,25,&#39;student&#39;);
person.sayName();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;把所有信息封装在了构造函数中&lt;br /&gt;
&lt;strong&gt;优点：&lt;/strong&gt; 在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点；通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型；&lt;br /&gt;
&lt;strong&gt;注意：&lt;/strong&gt; 不能使用对象字面量重写原型，如果在创建了实例的情况下，会切断所有现有实例与新原型之间的联系；&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 20 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2015/11/20/jsCreateObject/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2015/11/20/jsCreateObject/</guid>
        
        <category>工厂模式</category>
        
        <category>构造函数模式</category>
        
        <category>原型模式</category>
        
        
      </item>
    
      <item>
        <title>表单常用代码</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;1.去除字符串左右两边的空格&lt;/h1&gt;

&lt;style type=&quot;text/css&quot;&gt;
	p{
		margin: 10px 0;
	}
	img{
		margin-top: 5px !important;
	}
&lt;/style&gt;

&lt;div&gt;
	&lt;textarea id=&quot;tvalue&quot; width=&quot;500&quot; height=&quot;200&quot;&gt;  我的左右两边都有空格   &lt;/textarea&gt;&lt;br /&gt;
	&lt;input type=&quot;button&quot; id=&quot;tbtn&quot; value=&quot;过滤&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;inputObj.value.replace(/^(\s|\u00A0)+|(\s|\u00A0)+$/g, &quot;&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var tvalue = document.getElementById(&quot;tvalue&quot;),
		tbtn = document.getElementById(&quot;tbtn&quot;);

	tbtn.onclick = function() {
		tvalue.value = tvalue.value.replace(/^(\s|\u00A0)+|(\s|\u00A0)+$/g, &quot;&quot;)
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;2.验证用户是否输入&lt;/h1&gt;

&lt;p&gt;&lt;input type=&quot;text&quot; id=&quot;cvalue&quot; value=&quot;kathyxxu&quot; /&gt;&lt;br /&gt;
&lt;input type=&quot;button&quot; id=&quot;cbtn&quot; value=&quot;验证是否为空&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(!inputObj.value.replace(/^(\s|\u00A0)+|(\s|\u00A0)+$/g, &quot;&quot;)){
    alert(&#39;empty input&#39;)
}else{
    alert(&#39;not empty input&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var cvalue = document.getElementById(&quot;cvalue&quot;),
		cbtn = document.getElementById(&quot;cbtn&quot;);
	cbtn.onclick = function() {
		if(!cvalue.value.replace(/^(\s|\u00A0)+|(\s|\u00A0)+$/g, &quot;&quot;)){
			alert(&#39;empty input&#39;)
		}else{
			alert(&#39;not empty input&#39;)
		}
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;3.禁止输入&lt;/h1&gt;

&lt;h4 id=&quot;disabled-readonly&quot;&gt;方案1.通过表单属性disabled readonly来控制输入&lt;/h4&gt;

&lt;p&gt;&lt;input type=&quot;text&quot; value=&quot;disabled&quot; disabled=&quot;&quot; /&gt;&lt;br /&gt;
&lt;input type=&quot;text&quot; value=&quot;disabled=&#39;disabled&#39;&quot; disabled=&quot;disabled&quot; /&gt;&lt;br /&gt;
&lt;input type=&quot;text&quot; value=&quot;readonly&quot; readonly=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&quot;text&quot; value=&quot;disabled&quot; disabled/&amp;gt;
&amp;lt;input type=&quot;text&quot; value=&quot;disabled=&#39;disabled&#39;&quot; disabled=&quot;disabled&quot;/&amp;gt;
&amp;lt;input type=&quot;text&quot; value=&quot;readonly&quot; readonly/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;disabled-禁用input元素。&lt;br /&gt;
无法与 &lt;code&gt;&amp;lt;input type=&quot;hidden&quot;&amp;gt;&lt;/code&gt;一起使用&lt;/li&gt;
  &lt;li&gt;readonly-字段为只读，不能修改。&lt;br /&gt;
可以用tab切换到该字段&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;js&quot;&gt;方案2.通过js来控制输入&lt;/h4&gt;
&lt;p&gt;js控制1-focus &amp;amp; blur &lt;input type=&quot;text&quot; value=&quot;禁止输入&quot; id=&quot;noInput1&quot; /&gt;&lt;br /&gt;
js控制2-keyup &amp;amp; blur &lt;input type=&quot;text&quot; value=&quot;禁止输入&quot; id=&quot;noInput2&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_noInput1.onfocus = function() {
    this.blur();
}

_noInput2.onkeyup = _noInput2.onblur = function() {
    this.value = &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;focus &amp;amp; blur&lt;br /&gt;
第一种写法更简洁，体验效果更好&lt;/li&gt;
  &lt;li&gt;keyup &amp;amp; blur&lt;br /&gt;
第二种写法代码较多，体验上有一点缺陷，输入的文字有一闪然后消失的过程&lt;br /&gt;
无法阻止通过鼠标复制粘贴来的文本，虽然失去焦点时会清空内容&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var _noInput1 = document.getElementById(&quot;noInput1&quot;);
	var _noInput2 = document.getElementById(&quot;noInput2&quot;);

	_noInput1.onfocus = function() {
		this.blur();
	}

	_noInput2.onkeyup = _noInput2.onblur = function() {
		this.value = &quot;&quot;;
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;关闭输入法&lt;/h1&gt;

&lt;h4 id=&quot;css-ime-mode&quot;&gt;方案1.使用css ime-mode属性&lt;/h4&gt;

&lt;p&gt;&lt;input type=&quot;text&quot; id=&quot;banInputMethod&quot; value=&quot;禁止输入法&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inputObj.style.imeMode = &#39;disabled&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;css非标准的ime-mode属性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设置或检索是否允许用户激活输入中文，韩文，日文等的输入法(ime)状态&lt;/li&gt;
  &lt;li&gt;取值 ime-mode : auto  active  inactive  disabled&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;auto&lt;/td&gt;
      &lt;td&gt;默认值，表示打开输入法。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;active&lt;/td&gt;
      &lt;td&gt;指定所有使用IME输入的字符。即激活本地语言输入法。用户仍可以撤销激活IME&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;inactive&lt;/td&gt;
      &lt;td&gt;指定所有不使用IME输入的字符。即激活非本地语言。用户仍可以撤销激活IME&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;disabled&lt;/td&gt;
      &lt;td&gt;完全禁用IME。对于有焦点的控件(如输入框)，用户不可以激活IME&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ime-mode的兼容性，如图 &lt;br /&gt;
&lt;img src=&quot;../../../../imgPost/2015-11-14/ime.png&quot; alt=&quot;&amp;quot;ime-mode的兼容性&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	function banInputMethodCSS(_elementArr) {
		var arr = _elementArr,
			self = this;
		if(!(_elementArr instanceof Array)) {
			arr = [_elementArr];
		}
		for(var i=0, arrLen=arr.length; i&lt;arrLen; i++) {
			var arrI = arr[i];
			arrI.onfocus = function() {
				// 兼容除了chrome之外的浏览器
				this.style.imeMode = &#39;disabled&#39;
			}
		}
	}
	banInputMethodCSS(document.getElementById(&quot;banInputMethod&quot;))
&lt;/script&gt;

&lt;h4 id=&quot;js-1&quot;&gt;方案2.js正则替换中文字符&lt;/h4&gt;
&lt;p&gt;&lt;input type=&quot;text&quot; id=&quot;banInputMethod2&quot; value=&quot;禁止输入法&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inputObj.value.replace(/[\u4e00-\u9fa5]/g, &quot;&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	function banInputMethodJS(_elementArr) {
		var arr = _elementArr,
			self = this;
		if(!(_elementArr instanceof Array)) {
			arr = [_elementArr];
		}
		var clearChinese = function(_this) {
			var _v = _this.value;
			_this.value = _v.replace(/[\u4e00-\u9fa5]/g, &quot;&quot;);
		}
		for(var i=0, arrLen=arr.length; i&lt;arrLen; i++) {
			var arrI = arr[i];
			arrI.onfocus = function() {
				clearChinese(this)
			}
			arrI.onkeyup = function() {
				clearChinese(this)
			}
		}
	}
	banInputMethodJS(document.getElementById(&quot;banInputMethod2&quot;))
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;禁止复制与粘贴&lt;/h1&gt;
&lt;p&gt;&lt;input type=&quot;text&quot; id=&quot;banCopyPaste&quot; value=&quot;禁止复制与粘贴&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inputObj.oncopy = function() {
    return false;
}
inputObj.onpaste = function() {
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var banCopyPaste = document.getElementById(&quot;banCopyPaste&quot;);
	banCopyPaste.oncopy = function() {
		return false;
	}
	banCopyPaste.onpaste = function() {
		return false;
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;限制只能输入数字/中文&lt;/h1&gt;

&lt;form&gt;
	type=&#39;number&#39;&lt;input type=&quot;number&quot; value=&quot;&quot; /&gt;&lt;br /&gt;
	pattern=[0-9]&lt;input type=&quot;text&quot; pattern=&quot;[0-9]&quot; value=&quot;&quot; /&gt;&lt;br /&gt;
	only number&lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;onlyNumber&quot; /&gt;&lt;br /&gt;
	only chinese&lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;onlyChinese&quot; /&gt;&lt;br /&gt;
	&lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;
&lt;/form&gt;

&lt;ul&gt;
  &lt;li&gt;type=’number’，只能输入数字，在手机端调起数字键盘；在提交表单时执行验证&lt;/li&gt;
  &lt;li&gt;pattern属性，验证输入字段的正则匹配模式，在提交表单时执行验证，适用text、search、url、telephone、mail、password&lt;/li&gt;
  &lt;li&gt;正则 &lt;code&gt;inputObj.value.replace(/\D/g,&quot;&quot;)&lt;/code&gt; 去除非数字，分别绑定到输入框的onfocus、onkeyup、onblur事件&lt;/li&gt;
  &lt;li&gt;正则 &lt;code&gt;inputObj.value.replace(/[^\u4e00-\u9fa5]/g, &quot;&quot;)&lt;/code&gt;去除非数字，分别绑定到输入框的onfocus、onkeyup、onblur事件&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var onlyNumber = document.getElementById(&quot;onlyNumber&quot;);
	var onlyChinese = document.getElementById(&quot;onlyChinese&quot;);

	var clearNonumber = function(tThis) {
		tThis.value = tThis.value.replace(/\D/g,&quot;&quot;)
	}
	onlyNumber.onfocus = function() {
		clearNonumber(this);
	}
	onlyNumber.onkeyup = function() {
		clearNonumber(this);
	}
	onlyNumber.onblur = function() {
		clearNonumber(this);
	}

	var clearNoChinese = function(tThis) {
		tThis.value = tThis.value.replace(/[^\u4e00-\u9fa5]/g, &quot;&quot;)
	}
	onlyChinese.onfocus = function() {
		clearNoChinese(this);
	}
	onlyChinese.onkeyup = function() {
		clearNoChinese(this);
	}
	onlyChinese.onblur = function() {
		clearNoChinese(this);
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;限制字符串长度(不区分中英文)&lt;/h1&gt;

&lt;h4 id=&quot;maxlength&quot;&gt;方案1. maxlength属性&lt;/h4&gt;

&lt;p&gt;maxlength限制 &lt;input type=&quot;text&quot; maxlength=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;input type=&quot;text&quot; maxlength=&quot;5&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;并非所有浏览器都支持maxlength属性&lt;/li&gt;
  &lt;li&gt;不区分中英文和数字的编码占位&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;js-2&quot;&gt;方案2. js控制&lt;/h4&gt;

&lt;p&gt;js限制 &lt;input type=&quot;text&quot; data-length=&quot;5&quot; id=&quot;limitLength&quot; data-model=&quot;Ch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inputObj.value = inputObj.value.substr(0, maxLength);&lt;/code&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var limitLength = document.getElementById(&quot;limitLength&quot;);
	var calLength = function(tThis) {
		var _v = tThis.value,
			_vLen = _v.length,
			dataLength = tThis.getAttribute(&quot;data-length&quot;),
			dataModel = tThis.getAttribute(&quot;data-model&quot;),
			subLen = dataLength;
		if(_vLen &gt; dataLength) {
			tThis.value = _v.substr(0, subLen);
		}

	}
	limitLength.onfocus = function() {
		calLength(this);
	}
	limitLength.onkeyup = function() {
		calLength(this);
	}
	limitLength.onblur = function() {
		calLength(this);
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;限制字符串长度(区分中英文) 并实时提示可输入字符&lt;/h1&gt;

&lt;style type=&quot;text/css&quot;&gt;
	.remainingCharacters{
		color: green;
		font-weight: bold;
	}
&lt;/style&gt;

&lt;p&gt;&lt;input type=&quot;text&quot; data-length=&quot;20&quot; id=&quot;remainingCharacters&quot; data-model=&quot;Ch&quot; data-remainingcharacters=&quot;charActers1,charActers2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;测试1：还可以输入&lt;span class=&quot;remainingCharacters&quot; id=&quot;charActers1&quot;&gt;20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;测试2：还可以输入&lt;span class=&quot;remainingCharacters&quot; id=&quot;charActers2&quot;&gt;20&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;data-model “En”-不区分中英文(默认) “Ch”-区分中英文&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var forElementArr = function(_elementArr, callBack) {
		var arr = _elementArr,
			self = this;
		if(!_elementArr instanceof Array) {
			arr = [_elementArr];
		}
		for(var i=0, arrLen=arr.length; i&lt;arrLen; i++) {
			var arrI = arr[i];
			if(typeof arrI == &quot;string&quot;) {
				arrI = document.getElementById(arrI);
			}
			callBack &amp;&amp; callBack(i, arrI);
		}
	}
	var showRemainingCharacters = function(_nums, _remainingCharacters) {
		if(_remainingCharacters.search(&quot;,&quot;) != -1) {
			_remainingCharacters = _remainingCharacters.split(&quot;,&quot;);
		}
		forElementArr(_remainingCharacters, function(_index, _this) {
			_this.innerHTML = (_nums &amp;&amp; _nums.toString()) || &quot;0&quot;;
		})
	}
	var strLen = (function() {
		var trim = function(chars) {
			return (chars || &quot;&quot;).replace(/^(\s|\u00A0)+|(\s|\u00A0)+$/g, &quot;&quot;)
		}
		return function(_str, _model) {
			_str = trim(_str);
			_model = _model || &quot;Ch&quot;;
			var _strLen = _str.length;
			if(_strLen == 0) {
				return 0;
			}
			else{
				var chinese = _str.match(/[\u4e00-\u9fa5]/g);
				return _strLen + (chinese &amp;&amp; _model == &quot;Ch&quot; ? chinese.length : 0);
			}
		}
	})()
	var remainingCharacters = document.getElementById(&quot;remainingCharacters&quot;);
	var calLength = function(tThis) {
		
		var _v = tThis.value,
			_vLen = _v.length,
			dataLength = tThis.getAttribute(&quot;data-length&quot;),
			dataModel = tThis.getAttribute(&quot;data-model&quot;),
			subLen = dataLength;
			remainingCharacters = tThis.getAttribute(&quot;data-remainingCharacters&quot;);
			
		if(dataModel == &quot;Ch&quot;) {
			_vLen = strLen(_v, dataModel);
			var vv = _v.match(/[\u4e00-\u9fa5]/g);
			subLen = dataLength - (!vv ? 0 : vv.length);
		}
		if(_vLen &gt; dataLength) {
			tThis.value = _v.substr(0, subLen);
			// for(var i=0; i&lt;tThis.value.length; i++) {
			// 	var str = tThis.
			// 	if()
			// }
		}

		if(remainingCharacters) {
			showRemainingCharacters(!_vLen ? dataLength : (_vLen &gt; dataLength ? 0 : dataLength - _vLen), remainingCharacters)
		}
	}
	remainingCharacters.onfocus = function() {
		calLength(this);
	}
	remainingCharacters.onkeyup = function() {
		calLength(this);
	}
	remainingCharacters.onblur = function() {
		calLength(this);
	}
&lt;/script&gt;

</description>
        <pubDate>Sat, 14 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2015/11/14/form/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2015/11/14/form/</guid>
        
        
      </item>
    
      <item>
        <title>webkit-box弹性盒子</title>
        <description>&lt;h1 id=&quot;icon&quot;&gt;栗子1：icon和文字对齐并居中显示&lt;/h1&gt;

&lt;!-- ![&quot;栗子1&quot;](../../../../imgPost/2015-11-09/1.png) --&gt;

&lt;style type=&quot;text/css&quot;&gt;
    .ajax-loader{
        margin: 30px 0 20px 0;
        width: 100%;
        height: 40px;
        display: -webkit-box;
        -webkit-box-pack: center;
        -webkit-box-align: center;
    }
    .ajax-loader i{
        display: block;
        background: url(&quot;../../../../imgPost/2015-11-09/ajax-loader.gif&quot;) no-repeat;
        width: 20px;
        height: 20px;
        background-size: contain;
        margin-right: 8px;
    }
    .ajax-loader span{
        display: block;
        font-size: 24px;
        color: #ababab;
        line-height: 40px !important;
    }
&lt;/style&gt;

&lt;div class=&quot;ajax-loader&quot;&gt;
    &lt;i class=&quot;ico ico-ajax-loader&quot;&gt;&lt;/i&gt;
    &lt;span&gt;正在加载...&lt;/span&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;ajax-loader&quot;&amp;gt;
    &amp;lt;i class=&quot;ico ico-ajax-loader&quot;&amp;gt;&amp;lt;/i&amp;gt;
    &amp;lt;span&amp;gt;正在加载...&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;style type=&quot;text/css&quot;&amp;gt;
    .ajax-loader{
        width: 100%;
        height: 40px;
        display: -webkit-box;
        -webkit-box-pack: center;
        -webkit-box-align: center;
    }
    .ajax-loader i{
        display: block;
        background: url(&quot;../../../../imgPost/2015-11-09/ajax-loader.gif&quot;) no-repeat;
        width: 20px;
        height: 20px;
        background-size: contain;
        margin-right: 8px;
    }
    .ajax-loader span{
        display: block;
        font-size: 24px;
        color: #ababab;
        line-height: 40px !important;
    }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-webkit-box-pack: center;&lt;br /&gt;
水平方向，icon和图片当做一个整体，一起居中显示&lt;/p&gt;

&lt;p&gt;-webkit-box-align: center;&lt;br /&gt;
垂直方向，规定如何对齐框的子元素&lt;br /&gt;
&lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;webkit-box-flex&quot;&gt;栗子2：webkit-box-flex&lt;/h1&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .action-bar{
        padding: 0 !important;
        margin: 20px 0 30px 0;
        height: 45px;
        background-color: #f8f9fa;
        display: -webkit-box;
    }
    .action-item{
        display: -webkit-box;
        -webkit-box-pack: center;
        -webkit-box-align: center;
        -webkit-box-flex: 1;
        position: relative;
    }
    .action-item.action-item-0{
        -webkit-box-flex: 1;
    }
    .action-item.action-item-1{
        -webkit-box-flex: 2;
    }
    .action-item.action-item-2{
        -webkit-box-flex: 3;
    }
    .action-item i{
        display: block;
        background: url(&quot;../../../../imgPost/2015-11-09/icon-collect-light.png&quot;) no-repeat;
        width: 26px;
        height: 26px;
        background-size: contain;
        margin-right: 5px;
    }
    .action-item span{
        display: block;
        font-size: 16px;
        color: #777777;
    }
    .action-item:after{
        position: absolute;
        right: 0;
        bottom: 10px;
        top: 10px;
        width: 1px;
        content: &#39;&#39;;
        background-color: #DEDFE0;
    }
    .action-item:last-of-type:after{
        width: 0;
    }
    .action-item:active{
        background-color: #e5e6e7;
    }
&lt;/style&gt;

&lt;ul class=&quot;action-bar&quot;&gt;
    &lt;li class=&quot;action-item action-item-0&quot;&gt;
        &lt;i class=&quot;ico&quot;&gt;&lt;/i&gt;
        &lt;span&gt;截屏&lt;/span&gt;
    &lt;/li&gt;
    &lt;li class=&quot;action-item action-item-1&quot;&gt;
        &lt;i class=&quot;ico&quot;&gt;&lt;/i&gt;
        &lt;span&gt;收藏&lt;/span&gt;
    &lt;/li&gt;
    &lt;li class=&quot;action-item action-item-2&quot;&gt;
        &lt;i class=&quot;ico&quot;&gt;&lt;/i&gt;
        &lt;span&gt;我要&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;
    .action-bar{
        padding: 0 !important;
        margin: 20px 0 30px 0;
        height: 45px;
        background-color: #f8f9fa;
        display: -webkit-box;
    }
    .action-item{
        display: -webkit-box;
        -webkit-box-pack: center;
        -webkit-box-align: center;
        -webkit-box-flex: 1;
        position: relative;
    }
    .action-item.action-item-0{
        -webkit-box-flex: 1;
    }
    .action-item.action-item-1{
        -webkit-box-flex: 2;
    }
    .action-item.action-item-2{
        -webkit-box-flex: 3;
    }
    .action-item i{
        display: block;
        background: url(&quot;../../../../imgPost/2015-11-09/icon-collect-light.png&quot;) no-repeat;
        width: 26px;
        height: 26px;
        background-size: contain;
        margin-right: 5px;
    }
    .action-item span{
        display: block;
        font-size: 16px;
        color: #777777;
    }
    .action-item:after{
        position: absolute;
        right: 0;
        bottom: 10px;
        top: 10px;
        width: 1px;
        content: &#39;&#39;;
        background-color: #DEDFE0;
    }
    .action-item:last-of-type:after{
        width: 0;
    }
    .action-item:active{
        background-color: #e5e6e7;
    }
&amp;lt;/style&amp;gt;
&amp;lt;ul class=&quot;action-bar&quot;&amp;gt;
    &amp;lt;li class=&quot;action-item action-item-0&quot;&amp;gt;
        &amp;lt;i class=&quot;ico&quot;&amp;gt;&amp;lt;/i&amp;gt;
        &amp;lt;span&amp;gt;截屏&amp;lt;/span&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;action-item action-item-1&quot;&amp;gt;
        &amp;lt;i class=&quot;ico&quot;&amp;gt;&amp;lt;/i&amp;gt;
        &amp;lt;span&amp;gt;收藏&amp;lt;/span&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;action-item action-item-2&quot;&amp;gt;
        &amp;lt;i class=&quot;ico&quot;&amp;gt;&amp;lt;/i&amp;gt;
        &amp;lt;span&amp;gt;我要&amp;lt;/span&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 09 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2015/11/09/webkit-box/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2015/11/09/webkit-box/</guid>
        
        <category>webkit-box</category>
        
        
      </item>
    
      <item>
        <title>javascript模式笔记2——字面量和构造函数</title>
        <description>&lt;style type=&quot;text/css&quot;&gt;
	p{
		margin: 30px 0 5px 0;
	}
	img{
		margin-top: 5px !important;
	}
	.post-container h1, .post-container h2, .post-container h3, .post-container h4, .post-container h5, .post-container h6 {
    	margin: 60px 0 10px;
	}
	.post-container ul, .post-container ol {
	    margin-bottom: 20px;
	}
&lt;/style&gt;

&lt;h3 id=&quot;section&quot;&gt;对象字面量：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//开始定义一个空对象
var dog = {};
//添加属性
dog.name = &quot;wangwagn&quot;;
//添加方法
dog.getName = function(){
    return dog.name;
}


//改变属性和方法
dog.getName = function(){
    return &quot;Fido&quot;;
}

//删除属性和方法
delete dog.name;


//添加属性和方法
dog.say = function(){
    return &quot;Woof!&quot;;
}
dog.fleas = true;


//也可以在创建对象时，向其添加属性和方法
var dog = {
    name : &quot;wangwang&quot;;
    getName : function(){
        return this.name;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：全局变量（var 声明）不可删&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;创建对象的两种的方法&lt;/h3&gt;
&lt;p&gt;第一种是使用&lt;strong&gt;字面量&lt;/strong&gt;方法创建对象：&lt;code&gt;var oschina = {goes:&quot;far&quot;};&lt;/code&gt;&lt;br /&gt;
第二种是使用&lt;strong&gt;内置构造函数&lt;/strong&gt;创建对象：&lt;code&gt;var oschina = new Object();  car.gose = &quot;far&quot;;&lt;/code&gt;&lt;br /&gt;
我们应该尽量使用字面量方法创建对象，其显著优点在于它仅仅输入更短的字符。&lt;br /&gt;
但是选择它还有以下几个更重要的原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;选择字面量法创建对象强调该对象仅是一个可变的hash映射，而不是从对象中提取的属性或方法。&lt;/li&gt;
  &lt;li&gt;对使用Object构造函数相对，使用字面量在于它并没有作用域解析。因为可能以同样的名字创建一个局部函数，解释器需要从调用Object()的位置开始一直向上查询作用域链，知道发现全局Object构造函数&lt;/li&gt;
  &lt;li&gt;构造函数Object可以仅接受一个参数，并且还依赖传递的值，该Object()可能会委派另一个内置函数来创建对象，并且返回了一个并非期望的不同对象。如将数字、字符串、布尔值当做参数传递给Object构造函数，其结果是获得了以不同构造函数所创建的对象，例如：&lt;code&gt;var oschina = new Object(1);&lt;/code&gt; &lt;code&gt;ochina.constructor&lt;/code&gt;为Number；传递的值是动态的，直到运行时才确定其类型，这种行为会导致意想不到的结果。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;//一个空对象
var o = new Object();
console.log(o.constructor === Object);  //true


//一个数值对象
var o = new Object(1);
console.log(o.constructor === Number);  //true
console.log(o.toFixed(2));  //1.00


//一个字符串对象
var o = new Object(&quot;I am a string&quot;);
console.log(o.constructor === String);  //true
//一般的对象没有substring方法，但是字符串对象有
console.log(typeof o.substring);    //&quot;function&quot;


//一个布尔对象
var o = new Object(true);
console.log(o.constructor === Boolean);  //true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;自定义构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var Person = function(name){
    this.name = name;
    this.say = function(){
        return &quot;I&#39;am &quot; + this.name;
    };
}


var Person = function(name){
    //使用对象字面量模式创建一个新对象
    //var this = {};

    //向this添加属性和方法
    this.name = name;
    this.say = function(){
        return &quot;I&#39;am &quot; + this.name;
    };

    //return this;
}

var xuxuan = new Person(&quot;kathy&quot;);
console.log(xuxuan.say());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用new调用构造函数：&lt;br /&gt;
1. 创建一个空对象，并且this引用了该对象，同时还继承了该函数的原型&lt;br /&gt;
2. 属性和方法添加到this引用的对象中&lt;br /&gt;
3. 新创建的对象由this引用， 最后隐式地返回this（如果没有显示的返回其他对象）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;//var this = {};&lt;/code&gt;&lt;br /&gt;
以上语句并不是真相的全部哦。因为“空”对象实际上并不空，已从Person的原型中继承了许多成员，因此它更像下面的语句：&lt;br /&gt;
&lt;code&gt;//var this = Object.create(Person.prototype);&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Dec 2013 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2013/12/02/jsPatternNote_2/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2013/12/02/jsPatternNote_2/</guid>
        
        <category>js模式笔记</category>
        
        
      </item>
    
      <item>
        <title>javascript模式笔记1——基本技巧</title>
        <description>&lt;style type=&quot;text/css&quot;&gt;
	p{
		margin: 30px 0 5px 0;
	}
	img{
		margin-top: 5px !important;
	}
	.post-container h1, .post-container h2, .post-container h3, .post-container h4, .post-container h5, .post-container h6 {
    	margin: 60px 0 10px;
	}
	.post-container ul, .post-container ol {
	    margin-bottom: 20px;
	}
&lt;/style&gt;

&lt;h3 id=&quot;section&quot;&gt;关于全局变量&lt;/h3&gt;

&lt;p&gt;js使用函数管理作用域，变量在函数内声明，只在函数内有效，外部无法访问。&lt;br /&gt;
全局变量在函数外声明，在函数内无需声明就可使用。&lt;/p&gt;

&lt;p&gt;js如下特性，即&lt;strong&gt;意外创建全局变量：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以直接使用变量，甚至无需声明&lt;/li&gt;
  &lt;li&gt;有个暗示全局变量，即任何变量若未经声明，就为全局对象所有&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;myGolbal = &quot;hello&quot;;  //反模式
console.log(myGolbal);  //hello
console.log(window.myGolbal);  //hello
console.log(window[&quot;myGolbal&quot;]);  //hello
console.log(this.myGolbal);  //hello

function xx(){
    console.log(typeof this.myGolbal);  //&quot;string&quot;
    console.log(this.myGolbal); //hello
}
xx();

var Xu= function(){
    this.say = function(){
        console.log(typeof this.myGolbal);  //&quot;undefined&quot;
        console.log(this.myGolbal); //undefined
    }
}
var xu = new Xu();
xu.say();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;最小化全局变量：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用var声明&lt;/li&gt;
  &lt;li&gt;命名空间模式&lt;/li&gt;
  &lt;li&gt;自执行立即生效函数(the self-executing immediate functions)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;function foo(){
    var a = b = 0;
    // 结果：a-局部  b-全局
    // 解释：var a =( b= 0);  从右至左的操作符优先级；优先级高的是表达式b=0,此时b未声明；表达式的返回值为0，赋给var声明的局部变量a
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function foo(){
    var a, b;
    a = b = 0;
    // 这样，a，b都是全局变量
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;访问全局对象：&lt;/strong&gt;&lt;br /&gt;
这种方式通常能获得全局对象，因为this在函数内部作为一个函数调用（而不是通过构造器new创建）时，往往指向该全局对象。但是，在严格模式下会出错。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;use strict&quot;
var global = (function(){
    return this;
})();
console.log(global);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;varsingle-var-pattern&quot;&gt;单一var模式（Single var Pattern）&lt;/h3&gt;
&lt;p&gt;只是用一个var在函数顶部进行变量声明&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func(){
    var a = 1,
        b=2,
        sum = a + b,
        myobject = {},
        i,
        j;
    //....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;变量提升&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;myname = &quot;global&quot;;
function func(){
    console.log(myname); //undefined
    var myname = &quot;local&quot;;
    console.log(myname); //&quot;local&quot;
}
func();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的变量声明都提升到函数的最顶层&lt;br /&gt;
为避免混乱，最好在开始就声明要用的所有变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myname = &quot;global&quot;;
function func(){
    var myname;
    console.log(myname); //undefined
    var myname = &quot;local&quot;;
    console.log(myname); //&quot;local&quot;
}
func();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于变量代码处理两个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进入上下文：创建变量、函数声明、形式参数&lt;/li&gt;
  &lt;li&gt;代码运行：创建函数表达式和不合格标示符（未定义变量）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;for&quot;&gt;for循环&lt;/h3&gt;

&lt;p&gt;问题：每次都要访问数组的长度，导致速度变慢。尤其当myarray不是数组，而是HTML容器对象的时候。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(var i=0; i&amp;lt;myarray.length; i++){
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTML容器是DOM方法返回的对象：&lt;br /&gt;
document.getElementsByName()&lt;br /&gt;
document.getElementsByClassName()&lt;br /&gt;
document.getElementsByTagName()&lt;br /&gt;
documents.images&lt;br /&gt;
documents.links&lt;br /&gt;
documents.forms&lt;br /&gt;
document.forms[0].elements&lt;/p&gt;

&lt;p&gt;容器的问题在于他们在document（HTML页面）下是活动的查询，每次访问任何容器的长度是，也就是在查询活动的DOM，通常DOM操作是非常耗时的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优化：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用i++; 代替 i=i+1; i+=1;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(var i=0, max=myarray.length; i&amp;lt;max; i++){
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用最少的变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i, myarray=[5,9,&quot;dd&quot;];
for(i=myarray.length; i&amp;gt;0 ;i--){
    console.log(myarray[i-1]);
}


var i, myarray=[5,9,&quot;dd&quot;];
for(i=myarray.length; i--; ){
    console.log(myarray[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逐步减至0，因为同0比较长度效率更高&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myarray=[5,9,&quot;dd&quot;];
var i = myarray.length;
console.log(i); //3
while(i--){
    console.log(i);  //2 1 0
    console.log(myarray[i]);  //dd 9 5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;for-in&quot;&gt;for-in循环&lt;/h3&gt;

&lt;p&gt;for-in遍历非数组对象，不推荐遍历数组（当数组对象已经被自定义函数扩大后，这样做会导致逻辑错误）,&lt;br /&gt;
所以推荐for循环处理数组，for-in循环处理对象。&lt;br /&gt;
当遍历对象属性遇到原型链属性时，使用hasOwnProperty()非常重要！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var man={
    hands : 2,
    legs : 2,
    heads : 1
}

if(typeof Object.prototype.clone === &quot;undefined&quot;){
    Object.prototype.clone = function(){
        console.log(&quot;I&#39;m clone!&quot;);
    }
}


//不过滤，会打印出clone()
for(var i in man){
    console.log(i,&quot;:&quot;,man[i]);
}
/*
hands : 2
legs : 2
heads : 1
clone : (){
    console.log(&quot;I&#39;m clone!&quot;);
}
*/


//使用hasOwnProperty过滤原型属性
for(var i in man){
    if(man.hasOwnProperty(i)){
        console.log(i,&quot;:&quot;,man[i]);
    }
}
/*
hands : 2
legs : 2
heads : 1
*/


//另一种使用hasOwnProperty的模式是在Object.prototype中调用
for(var i in man){
    if(Object.prototype.hasOwnProperty.call(man,i)){
        console.log(i,&quot;:&quot;,man[i]);
    }
}


//使用本地变量缓存较长属性名
var i,
    hasOwn = Object.prototype.hasOwnProperty;
for(i in man){
    if(hasOwn.call(man,i)){
        console.log(i,&quot;:&quot;,man[i]);
    }
}


//一种格式化的变种（没有通过JSLint测试）省略了花括号，并将if语句放在同一行中
//好处：可读性强（拥有属性X的元素，就直接对其操作；更少的缩进达到循环的目的）
var i,
    hasOwn = Object.prototype.hasOwnProperty;
for(i in man) if(hasOwn.call(man,i)){
    console.log(i,&quot;:&quot;,man[i]);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;不要随意增加内置的原型&lt;/h3&gt;

&lt;p&gt;1.影响代码可维护性&lt;br /&gt;
2.给原型添加的属性在没有使用hasOwnProperty()时，可能在循环中出现，导致一些混乱&lt;/p&gt;

&lt;p&gt;可采用如下模式为原型增加自定义的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(typeof Object.prototype.myMethod !== &quot;function&quot;){
    Object.prototype.myMethod = function(){
        //.....
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;switch&quot;&gt;switch模式&lt;/h3&gt;

&lt;p&gt;要注意一点的是：避免使用fall-throughs（即有意不使用break语句，这样会使程序一直向下执行）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var inspect_me = 0,
    result = &quot;&quot;;

switch(inspect_me){
    case 0:
        result = &quot;zero&quot;;
        break;
    case 1 :
        result = &quot;one&quot;;
        break;
    default:
        result = &quot;unknow&quot;;
}

console.log(result);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;避免使用隐式类型转换&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var zero = 0;
if(zero == false){
    console.log(&quot;zero == false is true!&quot;);
}
if(zero === false){
    console.log(&quot;zero === false is true!&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：zero == false is true!&lt;br /&gt;
原因：js在使用比较语句时会执行隐式类型转换，false==0 or “”==0 会返回true；&lt;br /&gt;
为避免混淆，在使用比较语句的时候使用=== or !==&lt;/p&gt;

&lt;h3 id=&quot;eval&quot;&gt;避免使用eval()&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var property = &quot;name&quot;,
    method = &quot;getName&quot;;
var obj = {
    name:&quot;kathy&quot;,
    getName : function(){
        return this.name;
    }
};

//反模式
console.log(eval(&quot;obj.&quot;+property));
console.log(eval(&quot;obj.&quot;+method+&quot;()&quot;));


//推荐的方法，简单的使用[]访问动态属性
console.log(obj[property]);
console.log(obj[method]());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;eval()&lt;/code&gt;包含一些安全隐患，有可能执行被篡改过得代码（例如来自网络的代码），这是在处理一个Ajax请求的JSON响应时常见的反模式。在这些情况下，最好使用浏览器内置方法解析JSON请求，确保安全性和有效性。&lt;br /&gt;
注意：通过&lt;code&gt;setInterval()&lt;/code&gt;  &lt;code&gt;setTimeout()&lt;/code&gt;  &lt;code&gt;function()&lt;/code&gt;等构造函数来传递参数，大部分情况下会导致类似eval()隐患，应避免使用；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myFunc1 = function(){
    console.log(1);
}
var myFunc2 = function(p1,p2,p3){
    console.log(p1,p2,p3);
}

//反模式
setTimeout(&quot;myFunc1()&quot;,1000);
setTimeout(&quot;myFunc2(2,3,4)&quot;,2000);

//推荐的模式
setTimeout(myFunc1,3000);
setTimeout(myFunc2(7,8,9),4000);  // setTimeout(myFunc2(7,8,9),4000); 是立即执行的，所以设置4000不生效
setTimeout(function(){
    myFunc2(77,88,99);
},5000);

/*
7 8 9
1
2 3 4
1
77 88 99
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑使用&lt;strong&gt;new Function() 代替eval()&lt;/strong&gt;或者&lt;strong&gt;将eval()封装到一个即时函数中&lt;/strong&gt;。&lt;br /&gt;
这样做的好处是new Function()代码在局部函数空间运行，代码中任何var定义的变量不会自动成为全局变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(typeof one);   //&quot;undefined&quot;
console.log(typeof two);   //&quot;undefined&quot;
console.log(typeof three); //&quot;undefined&quot;

//使用eval
var jsstring = &quot;var one = 1; console.log(one);&quot;;
eval(jsstring);

//使用new Function
var jsstring = &quot;var two = 2; console.log(two);&quot;;
new Function(jsstring)();

//将eval封装到一个即时函数中
var jsstring = &quot;var three = 3; console.log(three);&quot;;
(function(){
    eval(jsstring);
})();

console.log(typeof one);    //&quot;number&quot;
console.log(typeof two);    //&quot;undefined&quot;
console.log(typeof three);  //&quot;undefined&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;eval()&lt;/code&gt;可以访问和修改它外部作用域的变量&lt;br /&gt;
&lt;code&gt;Function&lt;/code&gt;多类似一个沙盒，无论在哪里执行，只能看到全局作用域&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(){
    var local = 1;
    //eval可以访问和修改它外部作用域的变量
    eval(&quot;local = 3; console.log(local)&quot;); //3
    console.log(local);  //3
})();


(function(){
    var local = 1;
    //Function就不可以，它仅能看到全局作用域
    new Function(&quot;local = 3; console.log(local)&quot;)();  //3
    console.log(local);  //1
})();


(function(){
    var local = 1;
    eval(&quot;console.log(typeof local)&quot;); //&quot;number&quot;
    console.log(local);  //1
})();


var global = &quot;golbal_var&quot;;
(function(){
    var local = 1;
    //Function类似一个沙盒，它仅能看到全局作用域(global)，因此对局部变量(local)的影响比较小
    Function(&quot;console.log(typeof local)&quot;)();  //&quot;undefined&quot;
    Function(&quot;console.log(typeof global)&quot;)();  //&quot;string&quot;
    console.log(local);  //1
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;parseint&quot;&gt;使用parseInt()的数值约定：&lt;/h3&gt;

&lt;p&gt;当解析的字符串是0开始，可能被当做8进制，为避免冲突，最好每次都指定具体进制参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var month = &quot;06&quot;;
var day = &quot;09&quot;;
month = parseInt(month,10);
day = parseInt(day,10);

console.log(month,day); // 6 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两个方法将非数值–&amp;gt;数值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box1 = &quot;08&quot;;
console.log(typeof +box1); //number

var box2 = Number(&quot;08&quot;);
console.log(typeof box2);  //number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较：&lt;br /&gt;
parseInt()——解析&lt;br /&gt;
Number()——简单转换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(Number(&quot;012xx&quot;)); //NaN
console.log(Number(&quot;xx012&quot;)); //NaN
console.log(parseInt(&quot;012xx&quot;)); //12
console.log(parseInt(&quot;xx012&quot;)); //NaN,如果第一个不是数值，就返回NaN
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 25 Nov 2013 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2013/11/25/jsPatternNote_1/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2013/11/25/jsPatternNote_1/</guid>
        
        <category>js模式笔记</category>
        
        
      </item>
    
      <item>
        <title>javascript基础一：六大基本数据类型Undefined、Null、Boolean、Number、String、Object</title>
        <description>&lt;style type=&quot;text/css&quot;&gt;
	p{
		margin: 30px 0 5px 0;
	}
	img{
		margin-top: 5px !important;
	}
&lt;/style&gt;

&lt;p&gt;&lt;strong&gt;5种简单数据类型：&lt;/strong&gt; Undefined、Null、Boolean、Number 和 String&lt;br /&gt;
&lt;strong&gt;1种复杂数据类型：&lt;/strong&gt; Object&lt;br /&gt;
&lt;strong&gt;typeof&lt;/strong&gt; 返回的是字符串，有六种可能：&lt;br /&gt;
“undefined”、”boolean”、”number”、”string”、”object”、”function”&lt;/p&gt;

&lt;h2 id=&quot;undefined-vs-null-vs-nan&quot;&gt;undefined vs null vs NaN&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var a1;
var a2 = true;
var a3 = 1;
var a4 = &quot;Hello&quot;;
var a5 = new Object();
var a6 = null;
var a7 = NaN;
var a8 = undefined;
alert(typeof a);  //显示&quot;undefined&quot;
alert(typeof a1); //显示&quot;undefined&quot;
alert(typeof a2); //显示&quot;boolean&quot;
alert(typeof a3); //显示&quot;number&quot;
alert(typeof a4); //显示&quot;string&quot;
alert(typeof a5); //显示&quot;object&quot;
alert(typeof a6); //显示&quot;object&quot;
alert(typeof a7); //显示&quot;number&quot;
alert(typeof a8); //显示&quot;undefined&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;从上面的代码中可以看出:&lt;br /&gt;
1. 未定义的值和定义未赋值的为undefined&lt;br /&gt;
2. null是一种特殊的object&lt;br /&gt;
3. NaN是一种特殊的number&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;// 空的对象，表示这个对象创建了，里面没有东西
// var box = {};
var box = new Object();   // box是Object类型，值是[object,Object]，类型返回的字符串是object
alert(box);               // [object,Object]
alert(typeof box);        // &quot;object&quot;

//空对象，表示没有创建，就是一个null
var box = null;          // box是Null类型，值是null，类型返回的字符串是object
alert(box);              // null
alert(typeof box);       // &quot;object&quot;

var box = function(){ var a = 20;}
alert(box);              // function(){ var a = 20;}
alert(typeof  box);      // &quot;function&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：函数在ECMAScript 中是对象，不是一种数据类型。&lt;br /&gt;
所以，使用typeof 来区分function 和object 是非常有必要的!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var box;
alert(box);     // undefined
alert(cat);     // Uncaught ReferenceError: cat is not defined 浏览器报错
alert(typeof box);     // &quot;undefined&quot;
alert(typeof cat);     // &quot;undefined&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;变量&lt;/td&gt;
      &lt;td&gt;描述&lt;/td&gt;
      &lt;td&gt;值&lt;/td&gt;
      &lt;td&gt;类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;box&lt;/td&gt;
      &lt;td&gt;未初始化的变量&lt;/td&gt;
      &lt;td&gt;“undefined”&lt;/td&gt;
      &lt;td&gt;undefined&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cat&lt;/td&gt;
      &lt;td&gt;根本不存在的变量(未声明的变量)&lt;/td&gt;
      &lt;td&gt;报错&lt;/td&gt;
      &lt;td&gt;undefined&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Undefined&lt;/strong&gt; 类型只有一个值，即特殊的”undefined”。在使用var声明变量，但没有对其初始化时，这个变量的值就是undefined。无法使用 for/in 循环来枚举 undefined 属性，也不能用 delete 运算符来删除它。undefined 不是常量，可以把它设置为其他值。&lt;br /&gt;
&lt;strong&gt;Null&lt;/strong&gt; 类型是一个只有一个值，即特殊的值”null”。它表示一个空对象引用(指针)，而typeof操作符检测null会返回object。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box;
var car = null;
alert(box == car)  // true
alert(typeof box == typeof car)  // false
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;有个要说明的是：undefined 是派生自null 的，因此ECMA-262 规定对它们的相等性测试返回true。&lt;br /&gt;
&lt;code&gt;alert(undefined == null);   //true值相等&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(undefined === null); //false值相等，数据类型不等&lt;/code&gt;&lt;br /&gt;
由于undefined 和null 两个值的比较是相等的，所以，未初始化的变量和赋值为null 的变量会相等。&lt;br /&gt;
这时，可以采用typeof 变量的类型进行比较。但，建议还是养成编码的规范，不要忘记初始化变量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var a1;         //a1的值为undefined
var a2 = null;
var a3 = NaN;
alert(a1 == a2); //显示&quot;true&quot;
alert(a1 != a2); //显示&quot;false&quot;
alert(a1 == a3); //显示&quot;false&quot;
alert(a1 != a3); //显示&quot;true&quot;
alert(a2 == a3); //显示&quot;false&quot;
alert(a2 != a3); //显示&quot;true&quot;
alert(a3 == a3); //显示&quot;false&quot;
alert(a3 != a3); //显示&quot;true&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;从上面的例子可以得出结论：&lt;br /&gt;
1.undefined与null是相等；&lt;br /&gt;
2.NaN与任何值都不相等，与自己也不相等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;boolean&quot;&gt;Boolean&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var box = true;
alert(box == 1); //true
alert(box === 1); //false
alert(typeof box == typeof 1); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;强制性转——要将一个值转换为其对应的Boolean 值，可以使用转型函数Boolean()&lt;br /&gt;
隐式转换——if 条件语句里面的条件判断&lt;/p&gt;

&lt;p&gt;以下是其他类型转换成Boolean类型规则：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;数据类型&lt;/td&gt;
      &lt;td&gt;转换为true的值&lt;/td&gt;
      &lt;td&gt;转换为false的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;非空字符串&lt;/td&gt;
      &lt;td&gt;空字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;任何非0数值（包括无穷大）&lt;/td&gt;
      &lt;td&gt;0 和 NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Object&lt;/td&gt;
      &lt;td&gt;任何对象&lt;/td&gt;
      &lt;td&gt;null&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Undefined&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;undefined&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;number&quot;&gt;Number&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var box = 070;   //八进制
alert(box);      //56  -- 输出都是十进制！！！

var box = 079;
alert(box);      //无效的八进制，自动解析为79

浮点类型
var box = 03.8;
alert(box);      //error
var box = 3.80;
alert(box);      //3.8
var box = .8     //0.8 有效，但不推荐此写法

//由于保存浮点数值需要的内存空间比整型数值大两倍，因此ECMAScript 会自动将可以转换为整型的浮点数值转成为整型。
var box = 8.;   //小数点后面没有值，转换为8
var box = 12.0; //小数点后面是0，转成为12
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;alert(Number.MIN_VALUE); //最小值 5e-324
alert(Number.MAX_VALUE); //最大值 1.7976931348623157e+308

var box1 = 100e1000; //超出范围，Infinity
var box2 = -100e1000; //超出范围，-Infinity
alert(box1);   // Infinity
alert(box2);   // -Infinity

alert(Number.POSITIVE_INFINITY); //Infinity(正无穷)
alert(Number.NEGATIVE_INFINITY); //-Infinity(负无穷)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;isFinite()&lt;/code&gt;函数。如果没有超过，返回true，超过了返回false。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = 100e1000;
alert(isFinite(box));  // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NaN&lt;/code&gt;，即非数值(Not a Number)是一个特殊的值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = 0 / 0; //NaN
var box = 12 / 0; //Infinity
var box = 12 / 0 * 0; //NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过&lt;code&gt;Number.NaN&lt;/code&gt; 得到NaN 值，任何与NaN 进行运算的结果均为NaN，NaN 与自身不相等(NaN 不与任何值相等)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(Number.NaN); //NaN
alert(NaN+1); //NaN
alert(NaN == NaN) //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ECMAScript 提供了&lt;code&gt;isNaN()&lt;/code&gt;函数，用来判断这个值到底是不是NaN。isNaN()函数在接收到一个值之后，会尝试将这个值转换为数值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(isNaN(NaN)); //true
alert(isNaN(25)); //false，25 是一个数值
alert(isNaN(&#39;25&#39;)); //false，&#39;25&#39;是一个字符串数值，可以转成数值
alert(isNaN(&#39;Lee&#39;)); //true，&#39;Lee&#39;不能转换为数值
alert(isNaN(true)); //false， true可以转成成1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;isNaN()&lt;/code&gt;函数也适用于对象。在调用isNaN()函数过程中，首先会调用valueOf()方法，然后确定返回值是否能够转换成数值。如果不能，则基于这个返回值再调用toString()方法，再测试返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = {
    toString : function () {
        return &#39;123&#39;; //可以改成return &#39;Lee&#39;查看效果
    }
};
alert(isNaN(box)); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section&quot;&gt;非数值转换为数值&lt;/h4&gt;

&lt;p&gt;有3 个函数可以把非数值转换为数值：&lt;code&gt;Number()&lt;/code&gt;、&lt;code&gt;parseInt()&lt;/code&gt;和&lt;code&gt;parseFloat()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Number()&lt;/code&gt;函数是转型函数，可以用于任何数据类型，而另外两个则专门用于把字符串转成数值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(Number(true)); //1，Boolean 类型的true 和false 分别转换成1 和0
alert(Number(25)); //25，数值型直接返回
alert(Number(null)); //0，空对象返回0
alert(Number(undefined)); //NaN，undefined 返回NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是字符串，应该遵循以下规则：&lt;br /&gt;
1.只包含数值的字符串，会直接转成成十进制数值，如果包含前导0，即自动去掉。&lt;br /&gt;
&lt;code&gt;alert(Number(&#39;456&#39;)); //456&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(Number(&#39;070&#39;)); //70&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.只包含浮点数值的字符串，会直接转成浮点数值，如果包含前导和后导0，即自动去掉。&lt;br /&gt;
&lt;code&gt;alert(Number(&#39;08.90&#39;)); //8.9&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.如果字符串是空，那么直接转成成0。&lt;br /&gt;
&lt;code&gt;alert(Number(&#39;&#39;)); //0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4.如果不是以上三种字符串类型，则返回NaN。&lt;br /&gt;
&lt;code&gt;alert(Number(&#39;Lee123&#39;)); //NaN&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;5.如果是对象，首先会调用valueOf()方法，然后确定返回值是否能够转换成数值。如果&lt;br /&gt;
转换的结果是NaN，则基于这个返回值再调用toString()方法，再测试返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = {
    toString : function () {
        return &#39;123&#39;; //可以改成return &#39;Lee&#39;查看效果
    }
};
alert(Number(box)); //123
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于&lt;code&gt;Number()&lt;/code&gt;函数在转换字符串时比较复杂且不够合理，因此在处理整数的时候更常用的是&lt;code&gt;parseInt()&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(parsetInt(&#39;456Lee&#39;)); //456，会返回整数部分
alert(parsetInt(&#39;Lee456Lee&#39;)); //NaN，如果第一个不是数值，就返回NaN
alert(parseInt(&#39;12Lee56Lee&#39;)); //12，从第一数值开始取，到最后一个连续数值结束
alert(parseInt(&#39;56.12&#39;)); //56，小数点不是数值，会被去掉
alert(parseInt(&#39;&#39;)); //NaN，空返回NaN

//parseInt()除了能够识别十进制数值，也可以识别八进制和十六进制。
alert(parseInt(&#39;0xA&#39;)); //10，十六进制
alert(parseInt(&#39;070&#39;)); //56，八进制
alert(parseInt(&#39;0xALee&#39;)); //100，十六进制，Lee 被自动过滤掉

//ECMAScript 为parseInt()提供了第二个参数，用于解决各种进制的转换。
alert(parseInt(&#39;0xAF&#39;)); //175，十六进制
alert(parseInt(&#39;AF&#39;,16)); //175，第二参数指定十六进制，可以去掉0x 前导
alert(parseInt(&#39;AF&#39;)); //NaN，理所当然
alert(parseInt(&#39;101010101&#39;,2)); //314，二进制转换
alert(parseInt(&#39;70&#39;,8)) //56，八进制转换

//parseFloat()是用于浮点数值转换的，和parseInt()一样，从第一位解析到非浮点数值位置。
alert(parseFloat(&#39;123Lee&#39;)); //123，去掉不是别的部分
alert(parseFloat(&#39;0xA&#39;)); //0，不认十六进制
alert(parseFloat(&#39;123.4.5&#39;)); //123.4，只认一个小数点
alert(parseFloat(&#39;0123.400&#39;)); //123.4，去掉前后导
alert(parseFloat(&#39;1.234e7&#39;)); //12340000，把科学技术法转成普通数值
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;string&quot;&gt;String&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;字面量&lt;/td&gt;
      &lt;td&gt;含义&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\n&lt;/td&gt;
      &lt;td&gt;换行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\t&lt;/td&gt;
      &lt;td&gt;制表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\b&lt;/td&gt;
      &lt;td&gt;空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\r&lt;/td&gt;
      &lt;td&gt;回车&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\f&lt;/td&gt;
      &lt;td&gt;换页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\&lt;/td&gt;
      &lt;td&gt;斜杠&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&#39;&lt;/td&gt;
      &lt;td&gt;单引号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&quot;&lt;/td&gt;
      &lt;td&gt;双引号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\xnn&lt;/td&gt;
      &lt;td&gt;以十六进制代码nn表示的一个字符(0~F)。例：\x41&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\unnn&lt;/td&gt;
      &lt;td&gt;以十六进制代码nnn表示的一个Unicode字符(0~F)。例：\u01a9&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = &#39;Mr.&#39;;
box = box + &#39; Lee&#39;;   //把原来的‘Mr’复制一份，再加上‘Lee’，赋值给box，原来的‘Mr’销毁
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt;方法一般是不需要传参的，但在数值转成字符串的时候，可以传递进制参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = 10;
alert(box.toString()); //&#39;10&#39;，默认输出
alert(box.toString(2)); //&#39;1010&#39;，二进制输出
alert(box.toString(8)); //&#39;12&#39;，八进制输出
alert(box.toString(10)); //&#39;10&#39;，十进制输出
alert(box.toString(16)); //&#39;a&#39;，十六进制输出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在转型之前不知道变量是否是null 或者undefined 的情况下，我们还可以使用转型函数&lt;code&gt;String()&lt;/code&gt;，这个函数能够将任何类型的值转换为字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = null;
alert(String(box));//&#39;null&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;objec&quot;&gt;Objec&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var box = null;
var box = {};
var box = new Object();
var box = Object();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Object()里可以任意传参，可以传数值、字符串、布尔值等。而且，还可以进行相应的计算。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = new Object(2);  //Object 类型，值是2
alert(box);               //2
alert(typeof box);        //&quot;object&quot;
alert(box+2);             //4，可以和普通变量运算
alert(typeof (box+2));    //&quot;number&quot;，输出结果转型成Number类型了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Number，String，Boolean用&lt;code&gt;new&lt;/code&gt;出来的是Object类型&lt;br /&gt;
数组和对象不用new也是object类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = new Number(22);
alert(typeof box);   //object

var cat = 22;
alert(typeof cat);     //number
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 03 Sep 2013 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2013/09/03/jsBasic01/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2013/09/03/jsBasic01/</guid>
        
        <category>js基础</category>
        
        
      </item>
    
  </channel>
</rss>
