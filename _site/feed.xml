<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kathyxxu Blog</title>
    <description>前端工程师 | 这里是 @Kathyxxu 的个人博客，记录点点滴滴。</description>
    <link>http://kathyxxu.github.io/</link>
    <atom:link href="http://kathyxxu.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 07 Dec 2015 09:24:54 +0800</pubDate>
    <lastBuildDate>Mon, 07 Dec 2015 09:24:54 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>表单常用代码</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;1.去除字符串左右两边的空格&lt;/h1&gt;

&lt;style type=&quot;text/css&quot;&gt;
	p{
		margin: 10px 0;
	}
	img{
		margin-top: 5px !important;
	}
&lt;/style&gt;

&lt;div&gt;
	&lt;textarea id=&quot;tvalue&quot; width=&quot;500&quot; height=&quot;200&quot;&gt;  我的左右两边都有空格   &lt;/textarea&gt;&lt;br /&gt;
	&lt;input type=&quot;button&quot; id=&quot;tbtn&quot; value=&quot;过滤&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;inputObj.value.replace(/^(\s|\u00A0)+|(\s|\u00A0)+$/g, &quot;&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var tvalue = document.getElementById(&quot;tvalue&quot;),
		tbtn = document.getElementById(&quot;tbtn&quot;);

	tbtn.onclick = function() {
		tvalue.value = tvalue.value.replace(/^(\s|\u00A0)+|(\s|\u00A0)+$/g, &quot;&quot;)
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;2.验证用户是否输入&lt;/h1&gt;

&lt;p&gt;&lt;input type=&quot;text&quot; id=&quot;cvalue&quot; value=&quot;kathyxxu&quot; /&gt;&lt;br /&gt;
&lt;input type=&quot;button&quot; id=&quot;cbtn&quot; value=&quot;验证是否为空&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(!inputObj.value.replace(/^(\s|\u00A0)+|(\s|\u00A0)+$/g, &quot;&quot;)){
    alert(&#39;empty input&#39;)
}else{
    alert(&#39;not empty input&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var cvalue = document.getElementById(&quot;cvalue&quot;),
		cbtn = document.getElementById(&quot;cbtn&quot;);
	cbtn.onclick = function() {
		if(!cvalue.value.replace(/^(\s|\u00A0)+|(\s|\u00A0)+$/g, &quot;&quot;)){
			alert(&#39;empty input&#39;)
		}else{
			alert(&#39;not empty input&#39;)
		}
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;3.禁止输入&lt;/h1&gt;

&lt;h4 id=&quot;disabled-readonly&quot;&gt;方案1.通过表单属性disabled readonly来控制输入&lt;/h4&gt;

&lt;p&gt;&lt;input type=&quot;text&quot; value=&quot;disabled&quot; disabled=&quot;&quot; /&gt;&lt;br /&gt;
&lt;input type=&quot;text&quot; value=&quot;disabled=&#39;disabled&#39;&quot; disabled=&quot;disabled&quot; /&gt;&lt;br /&gt;
&lt;input type=&quot;text&quot; value=&quot;readonly&quot; readonly=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&quot;text&quot; value=&quot;disabled&quot; disabled/&amp;gt;
&amp;lt;input type=&quot;text&quot; value=&quot;disabled=&#39;disabled&#39;&quot; disabled=&quot;disabled&quot;/&amp;gt;
&amp;lt;input type=&quot;text&quot; value=&quot;readonly&quot; readonly/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;disabled-禁用input元素。&lt;br /&gt;
无法与 &lt;code&gt;&amp;lt;input type=&quot;hidden&quot;&amp;gt;&lt;/code&gt;一起使用&lt;/li&gt;
  &lt;li&gt;readonly-字段为只读，不能修改。&lt;br /&gt;
可以用tab切换到该字段&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;js&quot;&gt;方案2.通过js来控制输入&lt;/h4&gt;
&lt;p&gt;js控制1-focus &amp;amp; blur &lt;input type=&quot;text&quot; value=&quot;禁止输入&quot; id=&quot;noInput1&quot; /&gt;&lt;br /&gt;
js控制2-keyup &amp;amp; blur &lt;input type=&quot;text&quot; value=&quot;禁止输入&quot; id=&quot;noInput2&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_noInput1.onfocus = function() {
    this.blur();
}

_noInput2.onkeyup = _noInput2.onblur = function() {
    this.value = &quot;&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;focus &amp;amp; blur&lt;br /&gt;
第一种写法更简洁，体验效果更好&lt;/li&gt;
  &lt;li&gt;keyup &amp;amp; blur&lt;br /&gt;
第二种写法代码较多，体验上有一点缺陷，输入的文字有一闪然后消失的过程&lt;br /&gt;
无法阻止通过鼠标复制粘贴来的文本，虽然失去焦点时会清空内容&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var _noInput1 = document.getElementById(&quot;noInput1&quot;);
	var _noInput2 = document.getElementById(&quot;noInput2&quot;);

	_noInput1.onfocus = function() {
		this.blur();
	}

	_noInput2.onkeyup = _noInput2.onblur = function() {
		this.value = &quot;&quot;;
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;关闭输入法&lt;/h1&gt;

&lt;h4 id=&quot;css-ime-mode&quot;&gt;方案1.使用css ime-mode属性&lt;/h4&gt;

&lt;p&gt;&lt;input type=&quot;text&quot; id=&quot;banInputMethod&quot; value=&quot;禁止输入法&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inputObj.style.imeMode = &#39;disabled&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;css非标准的ime-mode属性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设置或检索是否允许用户激活输入中文，韩文，日文等的输入法(ime)状态&lt;/li&gt;
  &lt;li&gt;取值 ime-mode : auto  active  inactive  disabled&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;auto&lt;/td&gt;
      &lt;td&gt;默认值，表示打开输入法。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;active&lt;/td&gt;
      &lt;td&gt;指定所有使用IME输入的字符。即激活本地语言输入法。用户仍可以撤销激活IME&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;inactive&lt;/td&gt;
      &lt;td&gt;指定所有不使用IME输入的字符。即激活非本地语言。用户仍可以撤销激活IME&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;disabled&lt;/td&gt;
      &lt;td&gt;完全禁用IME。对于有焦点的控件(如输入框)，用户不可以激活IME&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ime-mode的兼容性，如图 &lt;br /&gt;
&lt;img src=&quot;../../../../imgPost/2015-11-14/ime.png&quot; alt=&quot;&amp;quot;ime-mode的兼容性&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	function banInputMethodCSS(_elementArr) {
		var arr = _elementArr,
			self = this;
		if(!(_elementArr instanceof Array)) {
			arr = [_elementArr];
		}
		for(var i=0, arrLen=arr.length; i&lt;arrLen; i++) {
			var arrI = arr[i];
			arrI.onfocus = function() {
				// 兼容除了chrome之外的浏览器
				this.style.imeMode = &#39;disabled&#39;
			}
		}
	}
	banInputMethodCSS(document.getElementById(&quot;banInputMethod&quot;))
&lt;/script&gt;

&lt;h4 id=&quot;js-1&quot;&gt;方案2.js正则替换中文字符&lt;/h4&gt;
&lt;p&gt;&lt;input type=&quot;text&quot; id=&quot;banInputMethod2&quot; value=&quot;禁止输入法&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inputObj.value.replace(/[\u4e00-\u9fa5]/g, &quot;&quot;)&lt;/code&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	function banInputMethodJS(_elementArr) {
		var arr = _elementArr,
			self = this;
		if(!(_elementArr instanceof Array)) {
			arr = [_elementArr];
		}
		var clearChinese = function(_this) {
			var _v = _this.value;
			_this.value = _v.replace(/[\u4e00-\u9fa5]/g, &quot;&quot;);
		}
		for(var i=0, arrLen=arr.length; i&lt;arrLen; i++) {
			var arrI = arr[i];
			arrI.onfocus = function() {
				clearChinese(this)
			}
			arrI.onkeyup = function() {
				clearChinese(this)
			}
		}
	}
	banInputMethodJS(document.getElementById(&quot;banInputMethod2&quot;))
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;禁止复制与粘贴&lt;/h1&gt;
&lt;p&gt;&lt;input type=&quot;text&quot; id=&quot;banCopyPaste&quot; value=&quot;禁止复制与粘贴&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;inputObj.oncopy = function() {
    return false;
}
inputObj.onpaste = function() {
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var banCopyPaste = document.getElementById(&quot;banCopyPaste&quot;);
	banCopyPaste.oncopy = function() {
		return false;
	}
	banCopyPaste.onpaste = function() {
		return false;
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;限制只能输入数字/中文&lt;/h1&gt;

&lt;form&gt;
	type=&#39;number&#39;&lt;input type=&quot;number&quot; value=&quot;&quot; /&gt;&lt;br /&gt;
	pattern=[0-9]&lt;input type=&quot;text&quot; pattern=&quot;[0-9]&quot; value=&quot;&quot; /&gt;&lt;br /&gt;
	only number&lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;onlyNumber&quot; /&gt;&lt;br /&gt;
	only chinese&lt;input type=&quot;text&quot; value=&quot;&quot; id=&quot;onlyChinese&quot; /&gt;&lt;br /&gt;
	&lt;input type=&quot;submit&quot; value=&quot;submit&quot; /&gt;
&lt;/form&gt;

&lt;ul&gt;
  &lt;li&gt;type=’number’，只能输入数字，在手机端调起数字键盘；在提交表单时执行验证&lt;/li&gt;
  &lt;li&gt;pattern属性，验证输入字段的正则匹配模式，在提交表单时执行验证，适用text、search、url、telephone、mail、password&lt;/li&gt;
  &lt;li&gt;正则 &lt;code&gt;inputObj.value.replace(/\D/g,&quot;&quot;)&lt;/code&gt; 去除非数字，分别绑定到输入框的onfocus、onkeyup、onblur事件&lt;/li&gt;
  &lt;li&gt;正则 &lt;code&gt;inputObj.value.replace(/[^\u4e00-\u9fa5]/g, &quot;&quot;)&lt;/code&gt;去除非数字，分别绑定到输入框的onfocus、onkeyup、onblur事件&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var onlyNumber = document.getElementById(&quot;onlyNumber&quot;);
	var onlyChinese = document.getElementById(&quot;onlyChinese&quot;);

	var clearNonumber = function(tThis) {
		tThis.value = tThis.value.replace(/\D/g,&quot;&quot;)
	}
	onlyNumber.onfocus = function() {
		clearNonumber(this);
	}
	onlyNumber.onkeyup = function() {
		clearNonumber(this);
	}
	onlyNumber.onblur = function() {
		clearNonumber(this);
	}

	var clearNoChinese = function(tThis) {
		tThis.value = tThis.value.replace(/[^\u4e00-\u9fa5]/g, &quot;&quot;)
	}
	onlyChinese.onfocus = function() {
		clearNoChinese(this);
	}
	onlyChinese.onkeyup = function() {
		clearNoChinese(this);
	}
	onlyChinese.onblur = function() {
		clearNoChinese(this);
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;限制字符串长度(不区分中英文)&lt;/h1&gt;

&lt;h4 id=&quot;maxlength&quot;&gt;方案1. maxlength属性&lt;/h4&gt;

&lt;p&gt;maxlength限制 &lt;input type=&quot;text&quot; maxlength=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;input type=&quot;text&quot; maxlength=&quot;5&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;并非所有浏览器都支持maxlength属性&lt;/li&gt;
  &lt;li&gt;不区分中英文和数字的编码占位&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;js-2&quot;&gt;方案2. js控制&lt;/h4&gt;

&lt;p&gt;js限制 &lt;input type=&quot;text&quot; data-length=&quot;5&quot; id=&quot;limitLength&quot; data-model=&quot;Ch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;inputObj.value = inputObj.value.substr(0, maxLength);&lt;/code&gt;&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var limitLength = document.getElementById(&quot;limitLength&quot;);
	var calLength = function(tThis) {
		var _v = tThis.value,
			_vLen = _v.length,
			dataLength = tThis.getAttribute(&quot;data-length&quot;),
			dataModel = tThis.getAttribute(&quot;data-model&quot;),
			subLen = dataLength;
		if(_vLen &gt; dataLength) {
			tThis.value = _v.substr(0, subLen);
		}

	}
	limitLength.onfocus = function() {
		calLength(this);
	}
	limitLength.onkeyup = function() {
		calLength(this);
	}
	limitLength.onblur = function() {
		calLength(this);
	}
&lt;/script&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-7&quot;&gt;限制字符串长度(区分中英文) 并实时提示可输入字符&lt;/h1&gt;

&lt;style type=&quot;text/css&quot;&gt;
	.remainingCharacters{
		color: green;
		font-weight: bold;
	}
&lt;/style&gt;

&lt;p&gt;&lt;input type=&quot;text&quot; data-length=&quot;20&quot; id=&quot;remainingCharacters&quot; data-model=&quot;Ch&quot; data-remainingcharacters=&quot;charActers1,charActers2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;测试1：还可以输入&lt;span class=&quot;remainingCharacters&quot; id=&quot;charActers1&quot;&gt;20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;测试2：还可以输入&lt;span class=&quot;remainingCharacters&quot; id=&quot;charActers2&quot;&gt;20&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;data-model “En”-不区分中英文(默认) “Ch”-区分中英文&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
	var forElementArr = function(_elementArr, callBack) {
		var arr = _elementArr,
			self = this;
		if(!_elementArr instanceof Array) {
			arr = [_elementArr];
		}
		for(var i=0, arrLen=arr.length; i&lt;arrLen; i++) {
			var arrI = arr[i];
			if(typeof arrI == &quot;string&quot;) {
				arrI = document.getElementById(arrI);
			}
			callBack &amp;&amp; callBack(i, arrI);
		}
	}
	var showRemainingCharacters = function(_nums, _remainingCharacters) {
		if(_remainingCharacters.search(&quot;,&quot;) != -1) {
			_remainingCharacters = _remainingCharacters.split(&quot;,&quot;);
		}
		forElementArr(_remainingCharacters, function(_index, _this) {
			_this.innerHTML = (_nums &amp;&amp; _nums.toString()) || &quot;0&quot;;
		})
	}
	var strLen = (function() {
		var trim = function(chars) {
			return (chars || &quot;&quot;).replace(/^(\s|\u00A0)+|(\s|\u00A0)+$/g, &quot;&quot;)
		}
		return function(_str, _model) {
			_str = trim(_str);
			_model = _model || &quot;Ch&quot;;
			var _strLen = _str.length;
			if(_strLen == 0) {
				return 0;
			}
			else{
				var chinese = _str.match(/[\u4e00-\u9fa5]/g);
				return _strLen + (chinese &amp;&amp; _model == &quot;Ch&quot; ? chinese.length : 0);
			}
		}
	})()
	var remainingCharacters = document.getElementById(&quot;remainingCharacters&quot;);
	var calLength = function(tThis) {
		
		var _v = tThis.value,
			_vLen = _v.length,
			dataLength = tThis.getAttribute(&quot;data-length&quot;),
			dataModel = tThis.getAttribute(&quot;data-model&quot;),
			subLen = dataLength;
			remainingCharacters = tThis.getAttribute(&quot;data-remainingCharacters&quot;);
			
		if(dataModel == &quot;Ch&quot;) {
			_vLen = strLen(_v, dataModel);
			var vv = _v.match(/[\u4e00-\u9fa5]/g);
			subLen = dataLength - (!vv ? 0 : vv.length);
		}
		if(_vLen &gt; dataLength) {
			tThis.value = _v.substr(0, subLen);
			// for(var i=0; i&lt;tThis.value.length; i++) {
			// 	var str = tThis.
			// 	if()
			// }
		}

		if(remainingCharacters) {
			showRemainingCharacters(!_vLen ? dataLength : (_vLen &gt; dataLength ? 0 : dataLength - _vLen), remainingCharacters)
		}
	}
	remainingCharacters.onfocus = function() {
		calLength(this);
	}
	remainingCharacters.onkeyup = function() {
		calLength(this);
	}
	remainingCharacters.onblur = function() {
		calLength(this);
	}
&lt;/script&gt;

</description>
        <pubDate>Sat, 14 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2015/11/14/form/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2015/11/14/form/</guid>
        
        
      </item>
    
      <item>
        <title>webkit-box弹性盒子</title>
        <description>&lt;h1 id=&quot;icon&quot;&gt;栗子1：icon和文字对齐并居中显示&lt;/h1&gt;

&lt;!-- ![&quot;栗子1&quot;](../../../../imgPost/2015-11-09/1.png) --&gt;

&lt;style type=&quot;text/css&quot;&gt;
    .ajax-loader{
        margin: 30px 0 20px 0;
        width: 100%;
        height: 40px;
        display: -webkit-box;
        -webkit-box-pack: center;
        -webkit-box-align: center;
    }
    .ajax-loader i{
        display: block;
        background: url(&quot;../../../../imgPost/2015-11-09/ajax-loader.gif&quot;) no-repeat;
        width: 20px;
        height: 20px;
        background-size: contain;
        margin-right: 8px;
    }
    .ajax-loader span{
        display: block;
        font-size: 24px;
        color: #ababab;
        line-height: 40px !important;
    }
&lt;/style&gt;

&lt;div class=&quot;ajax-loader&quot;&gt;
    &lt;i class=&quot;ico ico-ajax-loader&quot;&gt;&lt;/i&gt;
    &lt;span&gt;正在加载...&lt;/span&gt;
&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;ajax-loader&quot;&amp;gt;
    &amp;lt;i class=&quot;ico ico-ajax-loader&quot;&amp;gt;&amp;lt;/i&amp;gt;
    &amp;lt;span&amp;gt;正在加载...&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;style type=&quot;text/css&quot;&amp;gt;
    .ajax-loader{
        width: 100%;
        height: 40px;
        display: -webkit-box;
        -webkit-box-pack: center;
        -webkit-box-align: center;
    }
    .ajax-loader i{
        display: block;
        background: url(&quot;../../../../imgPost/2015-11-09/ajax-loader.gif&quot;) no-repeat;
        width: 20px;
        height: 20px;
        background-size: contain;
        margin-right: 8px;
    }
    .ajax-loader span{
        display: block;
        font-size: 24px;
        color: #ababab;
        line-height: 40px !important;
    }
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-webkit-box-pack: center;&lt;br /&gt;
水平方向，icon和图片当做一个整体，一起居中显示&lt;/p&gt;

&lt;p&gt;-webkit-box-align: center;&lt;br /&gt;
垂直方向，规定如何对齐框的子元素&lt;br /&gt;
&lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;webkit-box-flex&quot;&gt;栗子2：webkit-box-flex&lt;/h1&gt;
&lt;style type=&quot;text/css&quot;&gt;
    .action-bar{
        padding: 0 !important;
        margin: 20px 0 30px 0;
        height: 45px;
        background-color: #f8f9fa;
        display: -webkit-box;
    }
    .action-item{
        display: -webkit-box;
        -webkit-box-pack: center;
        -webkit-box-align: center;
        -webkit-box-flex: 1;
        position: relative;
    }
    .action-item.action-item-0{
        -webkit-box-flex: 1;
    }
    .action-item.action-item-1{
        -webkit-box-flex: 2;
    }
    .action-item.action-item-2{
        -webkit-box-flex: 3;
    }
    .action-item i{
        display: block;
        background: url(&quot;../../../../imgPost/2015-11-09/icon-collect-light.png&quot;) no-repeat;
        width: 26px;
        height: 26px;
        background-size: contain;
        margin-right: 5px;
    }
    .action-item span{
        display: block;
        font-size: 16px;
        color: #777777;
    }
    .action-item:after{
        position: absolute;
        right: 0;
        bottom: 10px;
        top: 10px;
        width: 1px;
        content: &#39;&#39;;
        background-color: #DEDFE0;
    }
    .action-item:last-of-type:after{
        width: 0;
    }
    .action-item:active{
        background-color: #e5e6e7;
    }
&lt;/style&gt;

&lt;ul class=&quot;action-bar&quot;&gt;
    &lt;li class=&quot;action-item action-item-0&quot;&gt;
        &lt;i class=&quot;ico&quot;&gt;&lt;/i&gt;
        &lt;span&gt;截屏&lt;/span&gt;
    &lt;/li&gt;
    &lt;li class=&quot;action-item action-item-1&quot;&gt;
        &lt;i class=&quot;ico&quot;&gt;&lt;/i&gt;
        &lt;span&gt;收藏&lt;/span&gt;
    &lt;/li&gt;
    &lt;li class=&quot;action-item action-item-2&quot;&gt;
        &lt;i class=&quot;ico&quot;&gt;&lt;/i&gt;
        &lt;span&gt;我要&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;
    .action-bar{
        padding: 0 !important;
        margin: 20px 0 30px 0;
        height: 45px;
        background-color: #f8f9fa;
        display: -webkit-box;
    }
    .action-item{
        display: -webkit-box;
        -webkit-box-pack: center;
        -webkit-box-align: center;
        -webkit-box-flex: 1;
        position: relative;
    }
    .action-item.action-item-0{
        -webkit-box-flex: 1;
    }
    .action-item.action-item-1{
        -webkit-box-flex: 2;
    }
    .action-item.action-item-2{
        -webkit-box-flex: 3;
    }
    .action-item i{
        display: block;
        background: url(&quot;../../../../imgPost/2015-11-09/icon-collect-light.png&quot;) no-repeat;
        width: 26px;
        height: 26px;
        background-size: contain;
        margin-right: 5px;
    }
    .action-item span{
        display: block;
        font-size: 16px;
        color: #777777;
    }
    .action-item:after{
        position: absolute;
        right: 0;
        bottom: 10px;
        top: 10px;
        width: 1px;
        content: &#39;&#39;;
        background-color: #DEDFE0;
    }
    .action-item:last-of-type:after{
        width: 0;
    }
    .action-item:active{
        background-color: #e5e6e7;
    }
&amp;lt;/style&amp;gt;
&amp;lt;ul class=&quot;action-bar&quot;&amp;gt;
    &amp;lt;li class=&quot;action-item action-item-0&quot;&amp;gt;
        &amp;lt;i class=&quot;ico&quot;&amp;gt;&amp;lt;/i&amp;gt;
        &amp;lt;span&amp;gt;截屏&amp;lt;/span&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;action-item action-item-1&quot;&amp;gt;
        &amp;lt;i class=&quot;ico&quot;&amp;gt;&amp;lt;/i&amp;gt;
        &amp;lt;span&amp;gt;收藏&amp;lt;/span&amp;gt;
    &amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;action-item action-item-2&quot;&amp;gt;
        &amp;lt;i class=&quot;ico&quot;&amp;gt;&amp;lt;/i&amp;gt;
        &amp;lt;span&amp;gt;我要&amp;lt;/span&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 09 Nov 2015 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2015/11/09/webkit-box/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2015/11/09/webkit-box/</guid>
        
        <category>webkit-box</category>
        
        
      </item>
    
      <item>
        <title>javascript模式笔记4——对象创建模式</title>
        <description>&lt;style type=&quot;text/css&quot;&gt;
	p{
		margin: 30px 0 5px 0;
	}
	img{
		margin-top: 5px !important;
	}
	.post-container h1, .post-container h2, .post-container h3, .post-container h4, .post-container h5, .post-container h6 {
    	margin: 60px 0 10px;
	}
	.post-container ul, .post-container ol {
	    margin-bottom: 20px;
	}
&lt;/style&gt;

&lt;h1 id=&quot;namespace&quot;&gt;1.命名空间(namespace)&lt;/h1&gt;

&lt;h3 id=&quot;section&quot;&gt;1.1 命名空间模式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//5个全局变量
//反模式
//构造函数
function Parent(){}
function Child(){}

//一个变量
var some_var = 1 ;

//一些对象
var module1 = {};
module1.data = {
    a : 1,
    b : 2
};
var module2 = {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个全局对象重构上述代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//1个全局变量
//重构上述代码，创建一个全局对象MYAPP，改变所有函数和变量成为这个全局对象的属性
var MYAPP ={};
MYAPP.Parent = function(){};
MYAPP.Child = function(){};
MYAPP.some_var = 1;
//一个容器对象
MYAPP.modules = {};
//嵌套对象
MYAPP.modules.module1 = {};
MYAPP.modules.module1.data = {a:1, b:2};
MYAPP.modules.module2 = {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺点：&lt;br /&gt;
1、每个变量和函数都要附加前缀，字符多，代码下载量多&lt;br /&gt;
2、长嵌套名，属性解析时间加长&lt;br /&gt;
3、仅有一个全局实例意味着任何部分的代码都可以修改该全局实例&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.2 通用命名空间函数&lt;/h3&gt;

&lt;p&gt;由于程序复杂性增加，代码被分割成不同的文件，以及使用条件包含语句等多个因素，又假设您的代码是第一个定义某个命名空间或它内部的一个属性，这种做法已不再安全，添加到命名空间的一些属性可能已经存在，存在覆盖问题，应该事先检查：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//不安全的代码
var MYAPP = {};

//更好的代码风格
if(typeof MYAPP === &quot;undefined&quot;){
    mar MYAPP = {};
}

//或者用更短的语句
var MYAPP = MYAPP || {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题：大量重复的检查代码，如想定义MYAPP.modules.module2，要做3次检查！&lt;/p&gt;

&lt;p&gt;下面是一个命名空间函数的实现，如果已存在一个命名空间，不会重复创建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var MYAPP = MYAPP || {};
MYAPP.namespace = function(ns_string){
    var parts = ns_string.split(&quot;.&quot;),
        parent = MYAPP,
        i;


    //剥离最前面的冗余全局变量
    if(parts[0] === &quot;MYAPP&quot;){
        parts = parts.slice(1);
    }


    for(i=0; i&amp;lt;parts.length; i++){
        //如果它不存在，就创建一个属性
        if(typeof parent[parts[i]] === &quot;undefined&quot;){
            parent[parts[i]] = {};
        }
        parent = parent[parts[i]];
    }
    return parent;
}


//将返回值赋给一个局部变量
var module2 = MYAPP.namespace(&#39;MYAPP.modules.module2&#39;);
console.log(module2 === MYAPP.modules.module2); //true


MYAPP.namespace(&#39;modules.module2&#39;);
MYAPP.namespace(&quot;once.upon.a.time&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;../../../../imgPost/2013-12-10/1.png&quot; alt=&quot;&amp;quot;通用命名空间函数&amp;quot;&quot; /&gt; &lt;/p&gt;

&lt;h1 id=&quot;dependency-declaration&quot;&gt;依赖声明(dependency declaration)&lt;/h1&gt;

&lt;h1 id=&quot;module-pattern&quot;&gt;模块模式(module pattern)&lt;/h1&gt;

&lt;h1 id=&quot;sandbox-pattern&quot;&gt;沙箱模式(sandbox pattern)&lt;/h1&gt;

</description>
        <pubDate>Tue, 10 Dec 2013 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2013/12/10/jsPatternNote_4/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2013/12/10/jsPatternNote_4/</guid>
        
        <category>js模式笔记</category>
        
        
      </item>
    
      <item>
        <title>javascript模式笔记3——函数</title>
        <description>&lt;style type=&quot;text/css&quot;&gt;
	p{
		margin: 30px 0 5px 0;
	}
	img{
		margin-top: 5px !important;
	}
	.post-container h1, .post-container h2, .post-container h3, .post-container h4, .post-container h5, .post-container h6 {
    	margin: 60px 0 10px;
	}
	.post-container ul, .post-container ol {
	    margin-bottom: 20px;
	}
&lt;/style&gt;

&lt;h1 id=&quot;section&quot;&gt;1.函数&lt;/h1&gt;

&lt;p&gt;特点1. 函数是第一类对象（first-class object）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以在运行时动态创建，还可以在程序执行过程中创建&lt;/li&gt;
  &lt;li&gt;可以分配给变量，可以将其引用复制到其他变量，可以被扩展，甚至可以被删除（除少数情况外）&lt;/li&gt;
  &lt;li&gt;可以作为参数传递给其他函数，也可以由其他函数返回&lt;/li&gt;
  &lt;li&gt;可以有自己的属性和方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特点2. 函数提供作用域&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;块不创建作用域，js中仅存在函数作用域&lt;/li&gt;
  &lt;li&gt;if for while的{ }中，使用var声明的变量，对于包装函数来说才是局部变量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1.1函数3类型&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;函数声明&lt;/li&gt;
  &lt;li&gt;命名函数表达式&lt;/li&gt;
  &lt;li&gt;未命名函数表达式&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//函数声明(function declaration)
function add(arg){}


//命名函数表达式(named function expression)
var add = function add(arg){};


//未命名函数表达式(unnamed function expression),也简称为函数表达式
//匿名函数(anonymous function)
var add = function(arg){};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;1.2函数的命名属性&lt;/h2&gt;

&lt;p&gt;函数有个只读属性&lt;code&gt;name&lt;/code&gt;，虽然不是标准属性，但是在很多环境中都可以使用它。在函数声明和命名函数表达式中，已定义了&lt;code&gt;name&lt;/code&gt;属性。在匿名函数表达式中，依赖于其实现方式，&lt;code&gt;name&lt;/code&gt;属性可能是未定义，也能是空字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(){}
var bar = function(){}
var baz = function baz(){}

console.log(foo.name);//foo
console.log(bar.name);//&quot;&quot;
console.log(baz.name);//baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;var foo = function bar(){ };&lt;/code&gt;&lt;br /&gt;
使用命名函数表达式将其分配给一个具有不同名称的变量，在技术上可行，但在一些浏览器中，这种行为没有被正确的实现，不推荐。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;1.3函数的提升&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    console.log(&quot;global foo&quot;);
}

function bar() {
    console.log(&quot;global bar&quot;);
}

function hoistMe(){
    console.log(typeof foo); //function
    console.log(typeof bar); //undefined

    foo(); //local foo
    bar(); //TypeError: undefined is not a function

    //函数声明
    //变量foo和函数实现都被提升
    function foo(){
        console.log(&quot;local foo&quot;);
    }

    //函数表达式
    //变量bar被提升————typeof bar里的bar是local的bar，而不是global的bar，所以输出undefined
    //函数实现没有被提升————所以执行bar();报错
    var bar = function(){
        console.log(&quot;local bar&quot;);
    };
}


hoistMe();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hoistMe()&lt;/code&gt;函数中的foo和bar，声明被提到的顶部，覆盖了全局的foo和bar。&lt;/p&gt;

&lt;p&gt;两者区别：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;函数&lt;/td&gt;
      &lt;td&gt;函数声明是否被提升&lt;/td&gt;
      &lt;td&gt;函数定义是否被提升&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;函数声明&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;函数表达式&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;apiapi-patterns&quot;&gt;2.API模式(API patterns)&lt;/h1&gt;
&lt;p&gt;为函数提供更好的接口&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;回调模式(Callback patterns)——将函数作为参数传递&lt;/li&gt;
  &lt;li&gt;配置对象(Configuration objects)——控制参数数量&lt;/li&gt;
  &lt;li&gt;返回函数(Returning functions)——当一个函数的返回值是另一个函数时&lt;/li&gt;
  &lt;li&gt;curry化(Currying)——新函数是基于现有函数，并加上部分参数列表创建时&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;callback-patterns&quot;&gt;2.1回调模式(Callback patterns)&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function writeCode(callback){
    //...
    callback();
    //...
}

function introduceBugs(){
    //...
}

writeCode(introduceBugs);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：&lt;code&gt;introduceBugs()&lt;/code&gt;作为参数传递给&lt;code&gt;writeCode()&lt;/code&gt;是不带括号的；&lt;br /&gt;
括号表示要执行函数，在这种情况下，我们只需要传递该函数的应用，让&lt;code&gt;writeCode()&lt;/code&gt;在适当的时候来执行它（也就是说，返回以后回调）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;回调示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var findNodes = function () {
    var i = 100000, // big, heavy loop
    nodes = [], // stores the result
    found; // the next node found
    while (i) {
        i -= 1;
        // complex logic here...
        nodes.push(found);
    }
    return nodes;
};


var hide = function (nodes) {
    var i = 0, max = nodes.length;
    for (; i &amp;lt; max; i += 1) {
        nodes[i].style.display = &quot;none&quot;;
    }
};
// executing the functions
hide(findNodes());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个实现是低效的，&lt;code&gt;hide()&lt;/code&gt;必须再次循环遍历由&lt;code&gt;findNodes()&lt;/code&gt;返回的数组节点。如果能在&lt;code&gt;findNodes()&lt;/code&gt;中实现隐藏逻辑，虽然高效，但是检索和修改逻辑耦合，它就不再是一个通用函数。&lt;/p&gt;

&lt;p&gt;解决办法就是采用回调模式，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// refactored findNodes() to accept a callback
var findNodes = function (callback) {
    var i = 100000,
    nodes = [],
    found;
    // check if callback is callable
    if (typeof callback !== &quot;function&quot;) {
        callback = false;
    }
    while (i) {
        i -= 1;
        // complex logic here...
        // now callback:
        if (callback) {
            callback(found);
        }
        nodes.push(found);
    }
    return nodes;
};


// a callback function
var hide = function (node) {
    node.style.display = &quot;none&quot;;
};
// find the nodes and hide them as you go
findNodes(hide);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;findNodes()&lt;/code&gt;执行的唯一额外任务就是检查是否提供了可选的回调函数，如果存在的话就执行；&lt;br /&gt;
由于回调函数是可选的，所以重构后的&lt;code&gt;findNodes()&lt;/code&gt;仍然可以像以前一样使用。这样，&lt;code&gt;hide()&lt;/code&gt;的实现就简单多了，不需要循环遍历所有节点。&lt;/p&gt;

&lt;p&gt;回调函数也可以是一个匿名函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// passing an anonymous callback
findNodes(function (node) {
    node.style.display = &quot;block&quot;;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;回调与作用域&lt;/h3&gt;

&lt;p&gt;问题的提出：回调函数不是一次性的匿名函数或全局函数，而是对象的方法，如果该回调方法使用&lt;code&gt;this&lt;/code&gt;来引用它所属的对象，会导致一些意外情况…&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myapp = {};
myapp.color = &quot;green&quot;;
myapp.paint = function(node){
    node.style.color = this.color;
}


var findNodes = function(callback){
    var node = document.getElementById(&quot;xx&quot;);
    if(typeof callback === &quot;function&quot;){
        callback(node);
    }
}


findNodes(myapp.paint);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;findNodes()&lt;/code&gt;是一个全局函数，因此this指向全局对象，所以&lt;code&gt;this.color&lt;/code&gt;没有被定义。如果&lt;code&gt;findNodes()&lt;/code&gt;是一个名为dom的对象的方法&lt;code&gt;(dom.findNodes())&lt;/code&gt;,那么回调内部的this指向dom，而不是预期的myapp。&lt;/p&gt;

&lt;p&gt;this 关键字的用法其实比较复杂，不过你只要牢记一句话就可以：&lt;br /&gt;
&lt;strong&gt;“this变量永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。如果处在匿名函数中、或者不处于任何对象中，this都指向宿主的根对象（在浏览器里面就是 window）”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;解决方案：传递回调函数，&lt;strong&gt;还传递该回调函数所属的对象&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myapp = {};
myapp.color = &quot;green&quot;;
myapp.paint = function(node){
    node.style.color = this.color;
}


var findNodes = function(callback, callback_obj){

    var node = document.getElementById(&quot;xx&quot;);

    if(typeof callback === &quot;function&quot;){
        callback.call(callback_obj, node);
    }

    if (typeof callback === &quot;string&quot;) {
        callback_obj[callback].call(callback_obj, node);
    }
}


findNodes(myapp.paint, myapp);
findNodes(&quot;paint&quot;, myapp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：以下实现方式，字体颜色也会发生变化，&lt;code&gt;findNodes&lt;/code&gt;函数的参数&lt;code&gt;myapp.paint(document.getElementById(&quot;xx&quot;))&lt;/code&gt;就是在执行一个函数，这个函数中的this指向的是myapp&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myapp = {};
myapp.color = &quot;green&quot;;
myapp.paint = function(node){
    node.style.color = this.color;
}


var findNodes = function(callback){
    if(typeof callback === &quot;function&quot;){
        callback();
    }
}


findNodes(myapp.paint(document.getElementById(&quot;xx&quot;)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他实现方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;__bind = function(fn, me){
    return function(){
        return fn.apply(me, arguments);
    };
};


var myapp = {};
myapp.color = &quot;green&quot;;
myapp.paint = function(node){
    node.style.color = this.color;
}


var findNodes = function(callback, callback_obj){
    var node = document.getElementById(&quot;xx&quot;);
    if(typeof callback === &quot;function&quot;){
        //指定callback的执行环境为callback_obj
        callback = __bind(callback, callback_obj); 
        callback(node);
    }
}


findNodes(myapp.paint, myapp);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;__bind = function(fn, me){
    return function(){
        return fn.apply(me, arguments);
    };
};


var myapp = {
    color : &quot;green&quot;,
    paint : function(node){
        node.style.color = this.color;
    }
};


//这里的myapp不可以写成this，this指向全局对象
myapp.paint = __bind(myapp.paint, myapp); 


var findNodes = function(callback){
    var node = document.getElementById(&quot;xx&quot;);
    if(typeof callback === &quot;function&quot;){
        callback(node);
    }
}


findNodes(myapp.paint);

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;__bind = function(fn, me){
    return function(){
        return fn.apply(me, arguments);
    };
};


function myapp(){
    this.color = &quot;green&quot;;
    //这里的this是myapp
    this.paint = __bind(this.paint, this); 
}


myapp.prototype.paint = function(node){
    node.style.color = this.color;
}


var findNodes = function(callback){
    var node = document.getElementById(&quot;xx&quot;);
    if(typeof callback === &quot;function&quot;){
        callback(node);
    }
}


var myappInstance = new myapp();
findNodes(myappInstance.paint);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ES5为所有的Function对象引入一个新的&lt;code&gt;bind&lt;/code&gt;方法，它实现下面的行为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myapp = {};
myapp.color = &quot;green&quot;;
myapp.paint = function(node){
    node.style.color = this.color;
}


var findNodes = function(callback, callback_obj){

    var node = document.getElementById(&quot;xx&quot;);

    if(typeof callback === &quot;function&quot;){
        // fn = callback.bind(callback_obj);
        // fn(node);
        callback.bind(callback_obj)(node);
    }
}


findNodes(myapp.paint, myapp);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较下两者用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var __bind = function(func, thisValue) {
    return function() {
        return func.apply(thisValue, arguments);
    }
}


var person = {
    name: &quot;Alex Russell&quot;,
    hello: function() { 
    	console.log(this.name + &quot; says hello world&quot;); 
    }
}


// $(&quot;#some-div&quot;).click(person.hello.bind(person));
$(&quot;#some-div&quot;).click(__bind(person.hello, person));

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;configuration-patterns&quot;&gt;2.2配置对象模式(Configuration patterns)&lt;/h2&gt;

&lt;p&gt;使用一个参数对象替代所有参数，将该参数称为conf，即配置的意思。&lt;br /&gt;
优点：控制参数数量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var conf = {
    username: &quot;batman&quot;,
    first: &quot;Bruce&quot;,
    last: &quot;Wayne&quot;
};
addPerson(conf);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;returning-functions&quot;&gt;2.3返回函数(Returning functions)&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var setup = function () {
    alert(1);
    return function () {
        alert(2);
    };
};

var my = setup(); // alerts 1
my(); // alerts 2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;var setup = function () {
    var count = 0;
    return function () {
        return (count += 1);
    };
};

var next = setup();
next(); // returns 1
next(); // 2
next(); // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;currycurrying&quot;&gt;2.4curry化(Currying)&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2.4.1函数调用&amp;amp;函数应用&lt;/h3&gt;

&lt;p&gt;函数调用 called/invoked&lt;br /&gt;
函数应用 applied，使用方法 &lt;code&gt;Function.prototype.apply()&lt;/code&gt;来应用函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//sayHi()是全局函数,可以直接调用
var sayHi = function(who){
    return &quot;Hello&quot; + (who ? &quot;, &quot; + who : &quot;&quot;) + &quot;!&quot;;
}


//函数调用（called or invoked）
console.log(sayHi());  //Hello!
console.log(sayHi(&quot;kathy&quot;));  //Hello, kathy!


//函数应用（applied），使用方法Function.prototype.apply()
//第一个参数 - 将要绑定到该函数内部this的一个对象，如果为null，this--&amp;gt;全局对象
//第二个参数 - 一个数组或多个参数变量，这些参数将变成可用于该函数内部的类似数组的arguments对象
console.log(sayHi.apply(null, [&quot;kathy&quot;])); //Hello, kathy!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个&lt;code&gt;apply()&lt;/code&gt;传递alien引用，内部的this指向alien对象，this.age是alien的age&lt;br /&gt;
第二个&lt;code&gt;apply()&lt;/code&gt;传递null引用，内部的this指向全局对象，this.age是全局的age&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//sayHi()是一个对象的方法，必须通过改对象调用
var age = 20;
var alien = {
    age : 15,
    sayHi : function(who){
        return &quot;Hello&quot; + (who ? &quot;, &quot; + who : &quot;&quot;) + &quot;! And you&#39;re &quot; + this.age + &quot; year&#39;s old ?&quot;;
    }
};


console.log(alien.sayHi(&quot;xuxuan&quot;)); //Hello, xuxuan! 
console.log(alien.sayHi.apply(alien,[&quot;xuxuan&quot;]));  //Hello, xuxuan! And you&#39;re 15 year&#39;s old ?
console.log(alien.sayHi.apply(null,[&quot;xuxuan&quot;]));  //Hello, xuxuan! And you&#39;re 20 year&#39;s old ?


console.log(sayHi(&quot;xuxuan&quot;));    //报错：sayHi未定义
console.log(sayHi.apply(alien,[&quot;xuxuan&quot;])); //报错：sayHi未定义
console.log(sayHi.apply(null,[&quot;xuxuan&quot;]));  //报错：sayHi未定义
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意&lt;code&gt;call&lt;/code&gt;和&lt;code&gt;apply&lt;/code&gt;的区别：&lt;br /&gt;
&lt;code&gt;Function.prototype.call&lt;/code&gt;是建立在&lt;code&gt;apply&lt;/code&gt;上的“语法糖”(syntax sugar): 当函数只有一个参数时，可以根据实际情况避免创建只有一个元素的数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//sayHi()是一个构造函数里的方法，必须通过实例调用
var age = 20;
var Alien = function(){
    this.age = 15;
    this.sayHi = function(who){
        return &quot;Hello&quot; + (who ? &quot;, &quot; + who : &quot;&quot;) + &quot;! And you&#39;re &quot; + this.age + &quot; year&#39;s old ?&quot;;
    };
};


var alien = new Alien();
console.log(alien.sayHi(&quot;xuxuan&quot;)); //Hello, xuxuan! And you&#39;re 15 year&#39;s old ?
console.log(alien.sayHi.apply(alien,[&quot;xuxuan&quot;]));  //Hello, xuxuan! And you&#39;re 15 year&#39;s old ?
console.log(alien.sayHi.apply(null,[&quot;xuxuan&quot;]));  //Hello, xuxuan! And you&#39;re 20 year&#39;s old ?


console.log(alien.sayHi.call(alien,&quot;xuxuan&quot;)); //Hello, xuxuan! And you&#39;re 15 year&#39;s old ?
console.log(alien.sayHi.call(null,&quot;xuxuan&quot;));  //Hello, xuxuan! And you&#39;re 20 year&#39;s old ?
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;partial-application&quot;&gt;2.4.2部分应用（partial application）&lt;/h3&gt;

&lt;p&gt;部分应用向我们提供了另一个函数，随后再以其他参数调用该函数。&lt;br /&gt;
假想的partialApply()方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var add = function(x, y){
    return x + y;
}

//完全应用
add.apply(null, [5,4]);  //9

//部分应用
var newadd = add.partialApply(null,[5]);

//应用一个参数到函数中
newadd.apply(null,[4]);  //9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上，js没有partialApply()方法，默认也不会表现出上述类似行为。但是可以构造出这种行为，成为&lt;code&gt;Curry&lt;/code&gt;过程。&lt;/p&gt;

&lt;h3 id=&quot;curry&quot;&gt;2.4.3Curry化&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function add(x, y){
    var oldx = x, oldy = y;
    //部分
    if(typeof oldy === &quot;undefined&quot;){
        return function(newly){
            return oldx + newly;
        }
    }
    //完全应用
    return x + y;
}


console.log(typeof add(5)); //function
console.log(add(3)(4));  //7


//add2000是一个新函数
var add2000 = add(2000);
console.log(add2000(13));  //2013
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更为精简的实现版本:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function add(x, y){
    //部分应用
    if(typeof y === &quot;undefined&quot;){
        return function(y){
            return x + y;
        }
    }
    //完全应用
    return x + y;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更通用的方式，将任意函数转换成一个新的可以接受部分参数的函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function schonfinkelize(fn){
    var slice = Array.prototype.slice,
        stored_args = slice.call(arguments, 1);
    return function(){
        var new_args = slice.call(arguments),
            args = stored_args.concat(new_args);
        return fn.apply(null, args);
    };
}


//普通函数
function add(x, y){
    return x + y;
}


//将一个函数curry化以获得一个新的函数
var newadd = schonfinkelize(add, 5);
console.log(newadd(4));  //9


//另一种用法————直接调用新函数
console.log(schonfinkelize(add,5)(4)); //9


//---------------------------------------------------------------


//普通函数
function add2(a, b, c, d, e){
    return a + b + c + d + e;
}


//两步curry化
var addOne = schonfinkelize(add2, 1);
console.log(addOne(10, 10, 10, 10));  //41


var addTow = schonfinkelize(addOne, 2, 3);  //addOne函数只用传递4个参数
console.log(addTow(5,5));  //16


//可运行于任意数量的参数
console.log(schonfinkelize(add2, 1, 2, 3)(5, 5));  //16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;curry使用场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用同一个函数，并且传递的参数绝大多数是相同的。&lt;/li&gt;
  &lt;li&gt;通过将一个函数集合部分应用到函数中，从而动态创建一个新函数。这个新函数会保存重复的参数（所以，不用每次都传这些重复的参数），而且还会使用预填充原始函数所期望的完整参数列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;initialization-patterns&quot;&gt;3.初始化模式(Initialization patterns)&lt;/h1&gt;

&lt;p&gt;不污染全局命名空间，使用临时变量，以一种更加整洁、结构化的方式执行初始化以及设置任务&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;即时函数(Immediate functions)——定义之后立即执行&lt;/li&gt;
  &lt;li&gt;即时对象初始化(Immediate object initialization)——匿名对象组织了初始化任务，提供了可被立即调用的方法&lt;/li&gt;
  &lt;li&gt;初始化时分支(Init-time branching)——帮助分支代码在初始化过程中仅检测一次&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;immediate-function-pattern&quot;&gt;3.1即时函数模式(Immediate Function pattern)&lt;/h2&gt;

&lt;p&gt;两种写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function () {
    alert(&#39;watch out!&#39;);
}());


(function () {
    alert(&#39;watch out!&#39;);
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作用：初始化代码提供了一个作用域沙箱(sandbox)。&lt;/p&gt;

&lt;p&gt;使用场景：页面加载时，需要一些初始化工作，而且仅需要执行一次，没有理由去创建一个可复用的命名函数。但是代码也需要一些临时变量，初始化阶段完成后就不需要了。以全局变量形式创建变量是一个差劲的方式。这时候，即时函数就可以派上用场了，我们将所有代码包装到它的局部作用域，且不会将任何变量泄露到全局作用域中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function () {
    var days = [&#39;Sun&#39;, &#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;],
        today = new Date(),
        msg = &#39;Today is &#39; + days[today.getDay()] + &#39;, &#39; + today.getDate();
    alert(msg); //Today is Tue, 26
}());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以将参数传到即时函数中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function (who, when) {
    console.log(&quot;I met &quot; + who + &quot; on &quot; + when);
}(&quot;Joe Black&quot;, new Date()));
//I met Joe Black on Tue Nov 26 2013 10:32:50 GMT+0800 (中国标准时间)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般情况下，全局对象是以参数的方式传递给及时函数，以便于在不使用window指定全局作用域限定的情况下可以在函数内部方位该对象，这样使得代码在浏览器环境之外时具有更好的互操作性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function (global) {
    // access the global object via `global`
}(this));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即时函数的返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//返回一个数值
var result = (function(){
    return 2 + 2;
}());


//另一种方式忽略包装函数的括号，因为将及时函数的返回值分配给一个变量时并不需要这些括号
var result = function(){
    return 2 + 2;
}();


//返回一个函数
var getResult = (function(){
    var res = 2 + 2;
    return function(){
        return res;
    };
}());
console.log(getResult);  //getResult是一个函数
/*
function (){
    return res;
}
*/
console.log(getResult());  //4


//当定义对象属性也可以用即时函数
//场景：需要定义一个对象在生命周期内永远不会改变的属性，但是在定义之前需要执行一些工作以找出正确的值，
//此时，使用即时函数包装这些工作，返回值将会成为属性值
var o = {
    message : (function(){
        var who = &quot;me&quot;,
            what = &quot;call&quot;;
        return what + &quot; &quot; + who;
    }()),
    getMsg : function(){
        return this.message;
    }
};

console.log(o.getMsg()); //call me
console.log(o.message); //call me
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;immediate-object-initialization&quot;&gt;3.2即时对象初始化(Immediate object initialization)&lt;/h2&gt;

&lt;p&gt;保护全局作用域：&lt;br /&gt;
- &lt;strong&gt;即时函数模式&lt;/strong&gt;(Immediate Function pattern)&lt;br /&gt;
- &lt;strong&gt;即时对象初始化&lt;/strong&gt;(Immediate object initialization)&lt;br /&gt;
  使用带有init( )方法的对象，该方法在对象创建后立即执行，init( )函数负责所有的初始化任务。&lt;/p&gt;

&lt;p&gt;以下两种写法都可以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;({...}).init();
({...}.init());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是即时对象模式的一个栗子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;({
    // here you can define setting values
    // a.k.a. configuration constants
    maxwidth: 600,
    maxheight: 400,
    // you can also define utility methods
    gimmeMax: function () {
        return this.maxwidth + &quot;x&quot; + this.maxheight;
    },
    // initialize
    init: function () {
        console.log(this.gimmeMax());
        // more init tasks...
    }
}).init();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优点：&lt;br /&gt;
1、执行一次性的初始化任务时保护全局命名空间&lt;br /&gt;
2、使整个初始化过程更有结构化&lt;/p&gt;

&lt;p&gt;缺点：&lt;br /&gt;
压缩问题，私有属性和方法不会被重命名为更短的名称。&lt;/p&gt;

&lt;p&gt;注意：&lt;br /&gt;
这种模式只适用于一次性任务，之后没有对该对象的访问。如果要的话，可以在&lt;code&gt;init( )&lt;/code&gt;尾部添加 &lt;code&gt;return this;&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;init-time-branching&quot;&gt;3.3初始化时分支(Init-time branching)&lt;/h2&gt;
&lt;p&gt;也称为加载时分支(load-time branching)，是一种一种优化模式。&lt;br /&gt;
当知道某个条件在整个程序声明周期内都不会发生改变的时候，仅对该条件测试一次是很有意义的。&lt;/p&gt;

&lt;p&gt;此段代码效率低下，每次调用&lt;code&gt;utils.addListenter( )&lt;/code&gt; 或者 &lt;code&gt;utils.removeListener( )&lt;/code&gt; 都会重复地执行相同的查:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// BEFORE
var utils = {
    addListener: function (el, type, fn) {
        if (typeof window.addEventListener === &#39;function&#39;) {
            el.addEventListener(type, fn, false);
        } else if (typeof document.attachEvent === &#39;function&#39;) { // IE
            el.attachEvent(&#39;on&#39; + type, fn);
        } else { // older browsers
            el[&#39;on&#39; + type] = fn;
        }
    },
    removeListener: function (el, type, fn) {
        // pretty much the same...
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方式：&lt;br /&gt;
使用初始化时分支，在脚本初始化加载时一次性嗅探出浏览器特称&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// AFTER
// the interface
var utils = {
    addListener: null,
    removeListener: null
};
// the implementation
if (typeof window.addEventListener === &#39;function&#39;) {
    utils.addListener = function (el, type, fn) {
        el.addEventListener(type, fn, false);
    };
    utils.removeListener = function (el, type, fn) {
        el.removeEventListener(type, fn, false);
    };
} else if (typeof document.attachEvent === &#39;function&#39;) { // IE
    utils.addListener = function (el, type, fn) {
        el.attachEvent(&#39;on&#39; + type, fn);
    };
    utils.removeListener = function (el, type, fn) {
        el.detachEvent(&#39;on&#39; + type, fn);
    };
} else { // older browsers
    utils.addListener = function (el, type, fn) {
        el[&#39;on&#39; + type] = fn;
    };
    utils.removeListener = function (el, type, fn) {
        el[&#39;on&#39; + type] = null;
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-6&quot;&gt;4.性能模式&lt;/h1&gt;
&lt;p&gt;加速代码运行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;备忘模式——使用函数属性存储计算结果&lt;/li&gt;
  &lt;li&gt;自定义模式——以新的主体重写本身，是的在第二次或以后调用时仅需执行更少的工作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;4.1备忘模式&lt;/h2&gt;

&lt;p&gt;给函数添加自定义属性，缓存函数结果，那么在下一次调用函数时，如果缓存在，就直接从缓存中取结果。就不用再做重复的繁琐的计算。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myFunc = function (param) {
    if (!myFunc.cache[param]) {
        var result = {};
        // ... expensive operation ...
        myFunc.cache[param] = result;
    }
    return myFunc.cache[param];
};
// cache storage
myFunc.cache = {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果参数复杂，可以将其序列化，如果序列化为一个JSON字符串。&lt;br /&gt;
注意：在序列化过程中，对象的“标识”将会丢失，如果有两个不同的对象并且恰好都有相同的属性，这两个对象会共享同一个缓存条目。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myFunc = function () {
    var cachekey = JSON.stringify(Array.prototype.slice.call(arguments)),
        result;
    if (!myFunc.cache[cachekey]) {
        result = {};
        // ... expensive operation ...
        myFunc.cache[cachekey] = result;
    }
    return myFunc.cache[cachekey];
};
// cache storage
myFunc.cache = {};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种方法使用&lt;code&gt;arguments.callee&lt;/code&gt;，注意ES5不支持&lt;code&gt;arguments.callee&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myFunc = function (param) {
    var f = arguments.callee,
    result;
    if (!f.cache[param]) {
        result = {};
        // ... expensive operation ...
        f.cache[param] = result;
    }
    return f.cache[param];
};
// cache storage
myFunc.cache = {};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-8&quot;&gt;4.2自定义模式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var scareMe = function () {
    alert(&quot;Boo!&quot;);
    scareMe = function () {
        alert(&quot;Double boo!&quot;);
    };
};

scareMe(); // Boo!
scareMe(); // Double boo!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也叫“惰性函数定义”(lazy funciton definition)，因为该函数直到第一次使用时才被正确定义，而且其具有后向惰性，执行了更少的工作。&lt;/p&gt;

&lt;p&gt;使用场景：当你的函数有一些初始化准备工作要做，并且仅需执行一次，自定义函数(self-defining funciton)可以更新自身的实现。&lt;/p&gt;

&lt;p&gt;优点：&lt;br /&gt;
可提升程序性能，因为重新定义的函数仅执行更少的工作。&lt;/p&gt;

&lt;p&gt;缺点：&lt;br /&gt;
1、重新定义自身时，已添加到原始函数的任何属性都会丢失；&lt;br /&gt;
2、如果函数使用了不同的名称（比如分配给不同的变量，或者以对象的方法来使用），那么重定义部分将永远不会发生，并且将会执行原始函数体。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scareMe = function () {
    alert(&quot;Boo!&quot;);
    scareMe = function () {
        alert(&quot;Double boo!&quot;);
    };
};


//添加一个新的属性
scareMe.property = &quot;properly&quot;;


// 赋值给一个不同的变量
var prank = scareMe;


// 作为一个方法使用
var spooky = {
    boo : scareMe
}


prank(); // Boo!
prank(); // Boo!
console.log(prank.property);//properly


spooky.boo(); // Boo!
spooky.boo(); // Boo!
console.log(spooky.boo.property);//properly


scareMe(); // Boo!
scareMe(); // Double boo!
console.log(scareMe.property);//undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意以下情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var scareMe = function () {
    alert(&quot;Boo!&quot;);
    scareMe = function () {
        alert(&quot;Double boo!&quot;);
    };
};


//添加一个新的属性
scareMe.property = &quot;properly&quot;;


// 赋值给一个不同的变量
var prank = scareMe;
prank(); // Boo!
prank(); // Boo!
console.log(prank.property);//properly


// 作为一个方法使用
var spooky = {
    boo : scareMe  //这个时候的scareMe经过上面prank()执行过后，是自身的更新函数了
}

spooky.boo(); // Double boo!
spooky.boo(); // Double boo!
console.log(spooky.boo.property);//undefined


scareMe(); // Double boo!
scareMe(); // Double boo!
console.log(scareMe.property);//undefined
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Thu, 05 Dec 2013 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2013/12/05/jsPatternNote_3/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2013/12/05/jsPatternNote_3/</guid>
        
        <category>js模式笔记</category>
        
        
      </item>
    
      <item>
        <title>javascript模式笔记2——字面量和构造函数</title>
        <description>&lt;style type=&quot;text/css&quot;&gt;
	p{
		margin: 30px 0 5px 0;
	}
	img{
		margin-top: 5px !important;
	}
	.post-container h1, .post-container h2, .post-container h3, .post-container h4, .post-container h5, .post-container h6 {
    	margin: 60px 0 10px;
	}
	.post-container ul, .post-container ol {
	    margin-bottom: 20px;
	}
&lt;/style&gt;

&lt;h3 id=&quot;section&quot;&gt;对象字面量：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//开始定义一个空对象
var dog = {};
//添加属性
dog.name = &quot;wangwagn&quot;;
//添加方法
dog.getName = function(){
    return dog.name;
}


//改变属性和方法
dog.getName = function(){
    return &quot;Fido&quot;;
}

//删除属性和方法
delete dog.name;


//添加属性和方法
dog.say = function(){
    return &quot;Woof!&quot;;
}
dog.fleas = true;


//也可以在创建对象时，向其添加属性和方法
var dog = {
    name : &quot;wangwang&quot;;
    getName : function(){
        return this.name;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：全局变量（var 声明）不可删&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;创建对象的两种的方法&lt;/h3&gt;
&lt;p&gt;第一种是使用&lt;strong&gt;字面量&lt;/strong&gt;方法创建对象：&lt;code&gt;var oschina = {goes:&quot;far&quot;};&lt;/code&gt;&lt;br /&gt;
第二种是使用&lt;strong&gt;内置构造函数&lt;/strong&gt;创建对象：&lt;code&gt;var oschina = new Object();  car.gose = &quot;far&quot;;&lt;/code&gt;&lt;br /&gt;
我们应该尽量使用字面量方法创建对象，其显著优点在于它仅仅输入更短的字符。&lt;br /&gt;
但是选择它还有以下几个更重要的原因：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;选择字面量法创建对象强调该对象仅是一个可变的hash映射，而不是从对象中提取的属性或方法。&lt;/li&gt;
  &lt;li&gt;对使用Object构造函数相对，使用字面量在于它并没有作用域解析。因为可能以同样的名字创建一个局部函数，解释器需要从调用Object()的位置开始一直向上查询作用域链，知道发现全局Object构造函数&lt;/li&gt;
  &lt;li&gt;构造函数Object可以仅接受一个参数，并且还依赖传递的值，该Object()可能会委派另一个内置函数来创建对象，并且返回了一个并非期望的不同对象。如将数字、字符串、布尔值当做参数传递给Object构造函数，其结果是获得了以不同构造函数所创建的对象，例如：&lt;code&gt;var oschina = new Object(1);&lt;/code&gt; &lt;code&gt;ochina.constructor&lt;/code&gt;为Number；传递的值是动态的，直到运行时才确定其类型，这种行为会导致意想不到的结果。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;//一个空对象
var o = new Object();
console.log(o.constructor === Object);  //true


//一个数值对象
var o = new Object(1);
console.log(o.constructor === Number);  //true
console.log(o.toFixed(2));  //1.00


//一个字符串对象
var o = new Object(&quot;I am a string&quot;);
console.log(o.constructor === String);  //true
//一般的对象没有substring方法，但是字符串对象有
console.log(typeof o.substring);    //&quot;function&quot;


//一个布尔对象
var o = new Object(true);
console.log(o.constructor === Boolean);  //true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;自定义构造函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var Person = function(name){
    this.name = name;
    this.say = function(){
        return &quot;I&#39;am &quot; + this.name;
    };
}


var Person = function(name){
    //使用对象字面量模式创建一个新对象
    //var this = {};

    //向this添加属性和方法
    this.name = name;
    this.say = function(){
        return &quot;I&#39;am &quot; + this.name;
    };

    //return this;
}

var xuxuan = new Person(&quot;kathy&quot;);
console.log(xuxuan.say());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用new调用构造函数：&lt;br /&gt;
1. 创建一个空对象，并且this引用了该对象，同时还继承了该函数的原型&lt;br /&gt;
2. 属性和方法添加到this引用的对象中&lt;br /&gt;
3. 新创建的对象由this引用， 最后隐式地返回this（如果没有显示的返回其他对象）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;//var this = {};&lt;/code&gt;&lt;br /&gt;
以上语句并不是真相的全部哦。因为“空”对象实际上并不空，已从Person的原型中继承了许多成员，因此它更像下面的语句：&lt;br /&gt;
&lt;code&gt;//var this = Object.create(Person.prototype);&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;构造函数的返回值&lt;/h3&gt;

&lt;p&gt;栗子1:&lt;br /&gt;
当new出一个对象，构造函数默认总是返回this引用的对象；&lt;br /&gt;
但是如果在构造函数中不向this添加任何成员，那么返回的对象也不是空的（继承了构造函数原型成员）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Person = function(){}

Person.prototype.name = &quot;student&quot;;
Person.prototype.say = function(){
    return &quot;I&#39;am &quot; + this.name;
}

var xuxuan = new Person();
console.log(xuxuan);
console.log(xuxuan.say());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;br /&gt;
&lt;img src=&quot;../../../../imgPost/2013-12-2/1.png&quot; alt=&quot;&amp;quot;栗子1&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;栗子2:&lt;br /&gt;
如果原型属性和方法和实例属性和方法同名， 查找顺序：&lt;strong&gt;先对象本身，后原型属性&lt;/strong&gt;,如果要访问原型中同名属性和方法，通过&lt;code&gt;__proto__&lt;/code&gt;来访问&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Person = function(){
    this.name = &quot;xuxuan&quot;;
    this.say = function(){
        return &quot;My name is &quot; + this.name;
    };
}

Person.prototype.name = &quot;student&quot;;
Person.prototype.say = function(){
    return &quot;I&#39;am a &quot; + this.name;
}

var xuxuan = new Person();
console.log(xuxuan);
console.log(xuxuan.name);
console.log(xuxuan.say());
console.log(xuxuan.__proto__.name);
console.log(xuxuan.__proto__.say());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;br /&gt;
&lt;img src=&quot;../../../../imgPost/2013-12-2/2.png&quot; alt=&quot;&amp;quot;栗子2&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;栗子3：&lt;br /&gt;
- 构造函数可以根据需要返回任意其他对象，只要它是一个对象；&lt;br /&gt;
- Person构造函数中，返回自定义对象that，这种模式的问题：&lt;strong&gt;丢失原型链的链接&lt;/strong&gt;，添加到Person原型的成员，对于对象来说都是不可用的；&lt;br /&gt;
- 如果返回并非对象的值，不会出错，但是函数会忽略该值，隐式地返回this所引用的对象；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var Person = function(){
    this.name = &quot;xuxuan&quot;;
    this.say = function(){
        return &quot;My name is &quot; + this.name;
    };

    var that = {};
    that.name = &quot;that&quot;;
    that.say = function(){
        return &quot;My name is &quot; + that.name;
    };
    return that;
}

Person.prototype.nameProto = &quot;student&quot;;
Person.prototype.sayProto = function(){
    return &quot;I&#39;am a &quot; + Person.prototype.nameProto;
}

var xuxuan = new Person();
console.log(xuxuan);
console.log(xuxuan.name);
console.log(xuxuan.say());
console.log(Person.prototype.nameProto);
console.log(Person.prototype.sayProto());
console.log(xuxuan.nameProto);
console.log(xuxuan.sayProto());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：&lt;br /&gt;
&lt;img src=&quot;../../../../imgPost/2013-12-2/3.png&quot; alt=&quot;&amp;quot;栗子3&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;栗子4：&lt;br /&gt;
将上例的return that; 改为 return 1;&lt;br /&gt;
输出：&lt;br /&gt;
&lt;img src=&quot;../../../../imgPost/2013-12-2/4.png&quot; alt=&quot;&amp;quot;栗子4&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;new&quot;&gt;强制使用new的模式&lt;/h3&gt;

&lt;p&gt;问题的提出：构造函数不用new调用，不会导致语法或运行错误，但是会导致逻辑错误，即this指向全局对象window&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var name = &quot;global&quot;;
function Person(){
    this.name = &quot;xuxuan&quot;;
}

var xx = new Person();
console.log(typeof xx);//object
console.log(xx.name);//xuxuan
console.log(xx instanceof Person);//true

console.log(window.name);//global
var oo = Person();
console.log(window.name);//xuxuan
console.log(typeof oo);//undefined
console.log(oo.name);//Uncaught TypeError: Cannot read property &#39;name&#39; of undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;这种意外情况在ECMAScript5中得到了解决，并且在严格模式下，this不会指向全局对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解决方式一：&lt;strong&gt;使用that&lt;/strong&gt;&lt;br /&gt;
缺点：丢失原型的链接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//下面的模式可以确保构造函数的行为总是表现出构造函数应有的行为
//这种模式的缺点：丢失原型的链接
function Person(){
    var that={};
    that.name = &quot;that&quot;;
    return that;
}

Person.prototype.wantMore = true;

var xx = new Person();
var oo = Person();
console.log(xx.name);//that
console.log(oo.name);//that
console.log(xx.wantMore);//undefined
console.log(oo.wantMore);//undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//对于简单的对象，可以仅仅从字面量返回一个对象
function Person(){
    return{
        name : &quot;that&quot;;
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方式二：&lt;strong&gt;自调用构造函数&lt;/strong&gt;&lt;br /&gt;
优点：解决了上述丢失原型链接的问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//在构造函数中检查this是否为构造函数的一个实例，如果否，构造函数再次调用自身，并在这次调用中正确的使用new操作符
function Person(){
    if(!(this instanceof Person)){
        return new Person();
    }
    this.name = &quot;xuxuan&quot;;
}

Person.prototype.wantMore = true;

var xx = new Person();
var oo = Person();
console.log(xx.name);//xuxuan
console.log(oo.name);//xuxuan
console.log(xx.wantMore);//true
console.log(oo.wantMore);//true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一种检测方法：将&lt;code&gt;this&lt;/code&gt;与&lt;code&gt;arguments.callee&lt;/code&gt;比较，而不是在代码中硬编码构造函数名称&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(!(this instanceof arguments.callee)){
    return new arguments.callee();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释：当函数被调用时，在每个函数内部将会创建一个名为&lt;code&gt;arguments&lt;/code&gt;的对象，包含了传递给该函数的所有参数；&lt;br /&gt;
同时，它有一个名为&lt;code&gt;callee&lt;/code&gt;的属性，指向被调用的函数；&lt;br /&gt;
注意：ES5严格模式不支持&lt;code&gt;arguments.callee&lt;/code&gt;属性&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;两种方法创建数组：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Array()构造函数&lt;/li&gt;
  &lt;li&gt;数组字面量&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;var a = new Array(&quot;foo&quot;,&quot;bar&quot;);
var b = [&quot;xx&quot;,&quot;oo&quot;];

console.log(typeof a);//object
console.log(typeof b);//object
console.log(a instanceof Array);//true
console.log(b instanceof Array);//true
console.log(a instanceof Object);//true
console.log(b instanceof Object);//true
console.log(a.constructor === Array);//true
console.log(b.constructor === Array);//true
console.log(a.constructor === Object);//false
console.log(b.constructor === Object);//false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数组字面量优点：&lt;br /&gt;
1. 语法简单、明确&lt;br /&gt;
2. 避免Array()构造函数可能产生的陷阱&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = [3];
console.log(a.length);  //1
console.log(a[0]);      //3


var a = new Array(3);
console.log(a.length);  //3
console.log(typeof a[0]); //undefined


var a = [3.14];
console.log(a.length);  //1
console.log(a[0]);      //3.14


var a = new Array(3.14);//Uncaught RangeError: Invalid array length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，可以巧妙地使用Array()构造函数，比如创建重复字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var white = new Array(5).join(&quot;a&quot;);
console.log(white);//aaaa
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;检查数组性质&lt;/h3&gt;

&lt;p&gt;当数组作为操作数并使用typeof操作符时，其结果会返回”object”，因为数组也是对象。但是这对于排除错误没有什么帮助，通常我们需要知道某个值是否为一个数组。有时候检查代码可以用是否存在length属性或一些数组方法，但是这些检查并非万能，我们无法确定一个非数组对象就不能拥有这些属性和方法。还可以使用&lt;code&gt;instanceof Array&lt;/code&gt;进行检查，但是这种检查存在兼容性问题。&lt;/p&gt;

&lt;p&gt;ECMAScript定义了&lt;code&gt;Array.isArray()&lt;/code&gt;方法，接受参数为数组时返回true。但是有些环境不支持这种方法，最好的检查数组性质的方法是&lt;code&gt;Object.prototype.toString.call&lt;/code&gt;方法，若是数组会返回&lt;code&gt;[object Array]&lt;/code&gt;，若是对象则为&lt;code&gt;[object object]&lt;/code&gt;，因此要用如下方法检测：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(typeof Array.isArray === &quot;undefined&quot;){
    Array.isArray = function(arg){
        return Object.prototype.toString.call(arg) === &quot;[object Array]&quot;;
    };
}

//调用Array.isArray()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;var xx = function(arg){
    return Object.prototype.toString.call(arg);
}
console.log(xx(false));   //[object Boolean]
console.log(xx(1));       //[object Number]
console.log(xx({}));      //[object Object]
console.log(xx([]));      //[object Array]
console.log(xx(new Number(1)));   //[object Number]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//测试：
console.log(Array.isArray([]));//true
console.log(Array.isArray({o:[1,2,3]}));//false


Array.isxxArray = function(arg){
    console.log(Object.prototype.toString());
    console.log(arg.toString());
    console.log(arg);
    return Object.prototype.toString.call(arg) === &quot;[object Array]&quot;;
}


console.log(Array.isxxArray([1,2,3]));
console.log(Array.isxxArray({o:[1,2,3]}));

/*
    [object Object]
    1,2,3
    [1, 2, 3]
    true
    [object Object]
    [object Object]
    Object {o: Array[3]}
    false
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;正则表达式的两种创建方法：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;字面量&lt;/li&gt;
  &lt;li&gt;new RegExp()构造函数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;var re = /\\/gm;
var re = new RegExp(&quot;\\\\&quot;,&quot;gm&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推荐字面量的方式：&lt;br /&gt;
1.字面量写法简短&lt;br /&gt;
2.new RegExp()，需要转义引号，还需要双反斜杠&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var no_letters = &quot;abc123XYZ&quot;.replace(/[a-z]/gi,&quot;&quot;);
console.log(no_letters);//123
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用new RegExp()的场景：&lt;br /&gt;
某些场景中无法实现确定模式，只能在运行时以字符串方式创建&lt;/p&gt;

&lt;p&gt;两者区别：&lt;br /&gt;
字面量在解析时只有一次创建了一个对象；&lt;br /&gt;
如果在一个循环中创建了相同的正则表达式（使用字面量的方式），那么后面返回的对象与前面创建的对象相同，并且将所有的属性将被设置为第一次的值。&lt;/p&gt;

&lt;p&gt;下面栗子演示了如何两次返回同一个对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getRE(){
    var re = /[a-z]/;
    re.foo = &quot;bar&quot;;
    return re;
}


var reg = new getRE(),
    reg2 = new getRE();
console.log(reg === reg2); //true
reg.foo = &quot;baz&quot;;
console.log(reg2.foo); //baz
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;但是，这种情况已经在ES5中得到改变，并且字面量会创建新的对象，许多浏览器已支持，所以这种模式并不可依赖哦~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-7&quot;&gt;基本类型值包装器&lt;/h3&gt;
&lt;p&gt;js 5个基本的值类型：数字、字符串、布尔、null、undefined&lt;br /&gt;
除了null、undefined，其他三个都有基本包装对象（primitive wrapper object）&lt;br /&gt;
Number()  String()  Boolean()&lt;/p&gt;

&lt;p&gt;栗子1：基本（primitive） vs.  对象（object）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var n = 100;
console.log(typeof n); //number

var nobj = new Number(&quot;100&quot;);
console.log(typeof nobj); //object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;栗子2:&lt;br /&gt;
包装对象包含了一些有用的属性和方法，但是这些方法在基本值类型上也能起作用，只要调用这些方法，基本值类型就可在在后台被临时转换为一个对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var s = &quot;hello&quot;;
console.log(s.toUpperCase()); //HELLO

console.log(&quot;monkey&quot;.slice(3,6)); //key

console.log((22/7).toPrecision(3)); //3.14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;栗子3：&lt;br /&gt;
使用包装对象的场景就是有扩充值以及持久保存状态的需要，因为基本值类型不是对象，不可能扩充属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//基本字符串
var greet = &quot;Hello there&quot;;


//为了使用split()方法，基本数据类型被转为对象
console.log(greet.split(&quot; &quot;)[0]); //Hello


//试图增加一个原始数据类型并不会导致错误
greet.smile = true;


//但是它并不会实际运行
console.log(greet.smile); //undefined


//包装对象
var sayHi = new String(&quot;Hi sweet&quot;);
sayHi.smile = true;
console.log(sayHi.smile); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;栗子4：&lt;br /&gt;
当使用没有带new操作符时，包装函数将传递进来的参数转成一个基本类型值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(typeof Number(1)); //number
console.log(typeof Number(&quot;1&quot;)); //number
console.log(typeof Number(new Number())); //number
console.log(Number(new Number())); //0
console.log(typeof String(1)); //string
console.log(typeof Boolean(1)); //boolean
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;在一般情况下，除了&lt;code&gt;Date()&lt;/code&gt;构造函数以外，很少需要用其他内置构造函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-8&quot;&gt;错误对象&lt;/h3&gt;

&lt;p&gt;js 内置错误构造函数：&lt;code&gt;Error()&lt;/code&gt; &lt;code&gt;SyntaxError()&lt;/code&gt; &lt;code&gt;TypeError()&lt;/code&gt; …&lt;br /&gt;
这些错误构造函数都带有&lt;code&gt;throw&lt;/code&gt;语句&lt;br /&gt;
错误对象有如下属性：&lt;br /&gt;
- name —— 错误类型&lt;br /&gt;
- message —— 错误消息&lt;br /&gt;
- 其他属性多个浏览器不一致，不可靠&lt;/p&gt;

&lt;p&gt;&lt;code&gt;throw&lt;/code&gt;用于任何对象，并不是由某个错误构造函数所创建的对象，因此可以选择抛出自己的对象。&lt;br /&gt;
这种错误对象可以有属性&lt;code&gt;name&lt;/code&gt;  &lt;code&gt;message&lt;/code&gt;，以及任意希望传递给&lt;code&gt;catch&lt;/code&gt;语句来处理的其他类型的信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try{
    //发生意外的事情，抛出一个错误
    throw {
        name:&quot;myErrorType&quot;,  //自定义错误类型
        message:&quot;oops&quot;,
        extra:&quot;This was rather embarrassing&quot;,
        remedy:genericErrorHandler  //指定应该处理该错误的函数
    };
}catch(e){
    alert(e.message);  //oops
    e.remedy();        //调用函数genericErrorHandler()
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 02 Dec 2013 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2013/12/02/jsPatternNote_2/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2013/12/02/jsPatternNote_2/</guid>
        
        <category>js模式笔记</category>
        
        
      </item>
    
      <item>
        <title>javascript模式笔记1——基本技巧</title>
        <description>&lt;style type=&quot;text/css&quot;&gt;
	p{
		margin: 30px 0 5px 0;
	}
	img{
		margin-top: 5px !important;
	}
	.post-container h1, .post-container h2, .post-container h3, .post-container h4, .post-container h5, .post-container h6 {
    	margin: 60px 0 10px;
	}
	.post-container ul, .post-container ol {
	    margin-bottom: 20px;
	}
&lt;/style&gt;

&lt;h3 id=&quot;section&quot;&gt;关于全局变量&lt;/h3&gt;

&lt;p&gt;js使用函数管理作用域，变量在函数内声明，只在函数内有效，外部无法访问。&lt;br /&gt;
全局变量在函数外声明，在函数内无需声明就可使用。&lt;/p&gt;

&lt;p&gt;js如下特性，即&lt;strong&gt;意外创建全局变量：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以直接使用变量，甚至无需声明&lt;/li&gt;
  &lt;li&gt;有个暗示全局变量，即任何变量若未经声明，就为全局对象所有&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;myGolbal = &quot;hello&quot;;  //反模式
console.log(myGolbal);  //hello
console.log(window.myGolbal);  //hello
console.log(window[&quot;myGolbal&quot;]);  //hello
console.log(this.myGolbal);  //hello

function xx(){
    console.log(typeof this.myGolbal);  //&quot;string&quot;
    console.log(this.myGolbal); //hello
}
xx();

var Xu= function(){
    this.say = function(){
        console.log(typeof this.myGolbal);  //&quot;undefined&quot;
        console.log(this.myGolbal); //undefined
    }
}
var xu = new Xu();
xu.say();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;最小化全局变量：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用var声明&lt;/li&gt;
  &lt;li&gt;命名空间模式&lt;/li&gt;
  &lt;li&gt;自执行立即生效函数(the self-executing immediate functions)&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;function foo(){
    var a = b = 0;
    // 结果：a-局部  b-全局
    // 解释：var a =( b= 0);  从右至左的操作符优先级；优先级高的是表达式b=0,此时b未声明；表达式的返回值为0，赋给var声明的局部变量a
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function foo(){
    var a, b;
    a = b = 0;
    // 这样，a，b都是全局变量
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;访问全局对象：&lt;/strong&gt;&lt;br /&gt;
这种方式通常能获得全局对象，因为this在函数内部作为一个函数调用（而不是通过构造器new创建）时，往往指向该全局对象。但是，在严格模式下会出错。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;use strict&quot;
var global = (function(){
    return this;
})();
console.log(global);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;varsingle-var-pattern&quot;&gt;单一var模式（Single var Pattern）&lt;/h3&gt;
&lt;p&gt;只是用一个var在函数顶部进行变量声明&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function func(){
    var a = 1,
        b=2,
        sum = a + b,
        myobject = {},
        i,
        j;
    //....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;变量提升&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;myname = &quot;global&quot;;
function func(){
    console.log(myname); //undefined
    var myname = &quot;local&quot;;
    console.log(myname); //&quot;local&quot;
}
func();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的变量声明都提升到函数的最顶层&lt;br /&gt;
为避免混乱，最好在开始就声明要用的所有变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myname = &quot;global&quot;;
function func(){
    var myname;
    console.log(myname); //undefined
    var myname = &quot;local&quot;;
    console.log(myname); //&quot;local&quot;
}
func();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于变量代码处理两个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进入上下文：创建变量、函数声明、形式参数&lt;/li&gt;
  &lt;li&gt;代码运行：创建函数表达式和不合格标示符（未定义变量）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;for&quot;&gt;for循环&lt;/h3&gt;

&lt;p&gt;问题：每次都要访问数组的长度，导致速度变慢。尤其当myarray不是数组，而是HTML容器对象的时候。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(var i=0; i&amp;lt;myarray.length; i++){
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTML容器是DOM方法返回的对象：&lt;br /&gt;
document.getElementsByName()&lt;br /&gt;
document.getElementsByClassName()&lt;br /&gt;
document.getElementsByTagName()&lt;br /&gt;
documents.images&lt;br /&gt;
documents.links&lt;br /&gt;
documents.forms&lt;br /&gt;
document.forms[0].elements&lt;/p&gt;

&lt;p&gt;容器的问题在于他们在document（HTML页面）下是活动的查询，每次访问任何容器的长度是，也就是在查询活动的DOM，通常DOM操作是非常耗时的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优化：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用i++; 代替 i=i+1; i+=1;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(var i=0, max=myarray.length; i&amp;lt;max; i++){
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用最少的变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i, myarray=[5,9,&quot;dd&quot;];
for(i=myarray.length; i&amp;gt;0 ;i--){
    console.log(myarray[i-1]);
}


var i, myarray=[5,9,&quot;dd&quot;];
for(i=myarray.length; i--; ){
    console.log(myarray[i]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;逐步减至0，因为同0比较长度效率更高&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myarray=[5,9,&quot;dd&quot;];
var i = myarray.length;
console.log(i); //3
while(i--){
    console.log(i);  //2 1 0
    console.log(myarray[i]);  //dd 9 5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;for-in&quot;&gt;for-in循环&lt;/h3&gt;

&lt;p&gt;for-in遍历非数组对象，不推荐遍历数组（当数组对象已经被自定义函数扩大后，这样做会导致逻辑错误）,&lt;br /&gt;
所以推荐for循环处理数组，for-in循环处理对象。&lt;br /&gt;
当遍历对象属性遇到原型链属性时，使用hasOwnProperty()非常重要！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var man={
    hands : 2,
    legs : 2,
    heads : 1
}

if(typeof Object.prototype.clone === &quot;undefined&quot;){
    Object.prototype.clone = function(){
        console.log(&quot;I&#39;m clone!&quot;);
    }
}


//不过滤，会打印出clone()
for(var i in man){
    console.log(i,&quot;:&quot;,man[i]);
}
/*
hands : 2
legs : 2
heads : 1
clone : (){
    console.log(&quot;I&#39;m clone!&quot;);
}
*/


//使用hasOwnProperty过滤原型属性
for(var i in man){
    if(man.hasOwnProperty(i)){
        console.log(i,&quot;:&quot;,man[i]);
    }
}
/*
hands : 2
legs : 2
heads : 1
*/


//另一种使用hasOwnProperty的模式是在Object.prototype中调用
for(var i in man){
    if(Object.prototype.hasOwnProperty.call(man,i)){
        console.log(i,&quot;:&quot;,man[i]);
    }
}


//使用本地变量缓存较长属性名
var i,
    hasOwn = Object.prototype.hasOwnProperty;
for(i in man){
    if(hasOwn.call(man,i)){
        console.log(i,&quot;:&quot;,man[i]);
    }
}


//一种格式化的变种（没有通过JSLint测试）省略了花括号，并将if语句放在同一行中
//好处：可读性强（拥有属性X的元素，就直接对其操作；更少的缩进达到循环的目的）
var i,
    hasOwn = Object.prototype.hasOwnProperty;
for(i in man) if(hasOwn.call(man,i)){
    console.log(i,&quot;:&quot;,man[i]);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;不要随意增加内置的原型&lt;/h3&gt;

&lt;p&gt;1.影响代码可维护性&lt;br /&gt;
2.给原型添加的属性在没有使用hasOwnProperty()时，可能在循环中出现，导致一些混乱&lt;/p&gt;

&lt;p&gt;可采用如下模式为原型增加自定义的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if(typeof Object.prototype.myMethod !== &quot;function&quot;){
    Object.prototype.myMethod = function(){
        //.....
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;switch&quot;&gt;switch模式&lt;/h3&gt;

&lt;p&gt;要注意一点的是：避免使用fall-throughs（即有意不使用break语句，这样会使程序一直向下执行）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var inspect_me = 0,
    result = &quot;&quot;;

switch(inspect_me){
    case 0:
        result = &quot;zero&quot;;
        break;
    case 1 :
        result = &quot;one&quot;;
        break;
    default:
        result = &quot;unknow&quot;;
}

console.log(result);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;避免使用隐式类型转换&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var zero = 0;
if(zero == false){
    console.log(&quot;zero == false is true!&quot;);
}
if(zero === false){
    console.log(&quot;zero === false is true!&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：zero == false is true!&lt;br /&gt;
原因：js在使用比较语句时会执行隐式类型转换，false==0 or “”==0 会返回true；&lt;br /&gt;
为避免混淆，在使用比较语句的时候使用=== or !==&lt;/p&gt;

&lt;h3 id=&quot;eval&quot;&gt;避免使用eval()&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var property = &quot;name&quot;,
    method = &quot;getName&quot;;
var obj = {
    name:&quot;kathy&quot;,
    getName : function(){
        return this.name;
    }
};

//反模式
console.log(eval(&quot;obj.&quot;+property));
console.log(eval(&quot;obj.&quot;+method+&quot;()&quot;));


//推荐的方法，简单的使用[]访问动态属性
console.log(obj[property]);
console.log(obj[method]());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;eval()&lt;/code&gt;包含一些安全隐患，有可能执行被篡改过得代码（例如来自网络的代码），这是在处理一个Ajax请求的JSON响应时常见的反模式。在这些情况下，最好使用浏览器内置方法解析JSON请求，确保安全性和有效性。&lt;br /&gt;
注意：通过&lt;code&gt;setInterval()&lt;/code&gt;  &lt;code&gt;setTimeout()&lt;/code&gt;  &lt;code&gt;function()&lt;/code&gt;等构造函数来传递参数，大部分情况下会导致类似eval()隐患，应避免使用；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var myFunc1 = function(){
    console.log(1);
}
var myFunc2 = function(p1,p2,p3){
    console.log(p1,p2,p3);
}

//反模式
setTimeout(&quot;myFunc1()&quot;,1000);
setTimeout(&quot;myFunc2(2,3,4)&quot;,2000);

//推荐的模式
setTimeout(myFunc1,3000);
setTimeout(myFunc2(7,8,9),4000);  // setTimeout(myFunc2(7,8,9),4000); 是立即执行的，所以设置4000不生效
setTimeout(function(){
    myFunc2(77,88,99);
},5000);

/*
7 8 9
1
2 3 4
1
77 88 99
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑使用&lt;strong&gt;new Function() 代替eval()&lt;/strong&gt;或者&lt;strong&gt;将eval()封装到一个即时函数中&lt;/strong&gt;。&lt;br /&gt;
这样做的好处是new Function()代码在局部函数空间运行，代码中任何var定义的变量不会自动成为全局变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(typeof one);   //&quot;undefined&quot;
console.log(typeof two);   //&quot;undefined&quot;
console.log(typeof three); //&quot;undefined&quot;

//使用eval
var jsstring = &quot;var one = 1; console.log(one);&quot;;
eval(jsstring);

//使用new Function
var jsstring = &quot;var two = 2; console.log(two);&quot;;
new Function(jsstring)();

//将eval封装到一个即时函数中
var jsstring = &quot;var three = 3; console.log(three);&quot;;
(function(){
    eval(jsstring);
})();

console.log(typeof one);    //&quot;number&quot;
console.log(typeof two);    //&quot;undefined&quot;
console.log(typeof three);  //&quot;undefined&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;eval()&lt;/code&gt;可以访问和修改它外部作用域的变量&lt;br /&gt;
&lt;code&gt;Function&lt;/code&gt;多类似一个沙盒，无论在哪里执行，只能看到全局作用域&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(){
    var local = 1;
    //eval可以访问和修改它外部作用域的变量
    eval(&quot;local = 3; console.log(local)&quot;); //3
    console.log(local);  //3
})();


(function(){
    var local = 1;
    //Function就不可以，它仅能看到全局作用域
    new Function(&quot;local = 3; console.log(local)&quot;)();  //3
    console.log(local);  //1
})();


(function(){
    var local = 1;
    eval(&quot;console.log(typeof local)&quot;); //&quot;number&quot;
    console.log(local);  //1
})();


var global = &quot;golbal_var&quot;;
(function(){
    var local = 1;
    //Function类似一个沙盒，它仅能看到全局作用域(global)，因此对局部变量(local)的影响比较小
    Function(&quot;console.log(typeof local)&quot;)();  //&quot;undefined&quot;
    Function(&quot;console.log(typeof global)&quot;)();  //&quot;string&quot;
    console.log(local);  //1
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;parseint&quot;&gt;使用parseInt()的数值约定：&lt;/h3&gt;

&lt;p&gt;当解析的字符串是0开始，可能被当做8进制，为避免冲突，最好每次都指定具体进制参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var month = &quot;06&quot;;
var day = &quot;09&quot;;
month = parseInt(month,10);
day = parseInt(day,10);

console.log(month,day); // 6 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两个方法将非数值–&amp;gt;数值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box1 = &quot;08&quot;;
console.log(typeof +box1); //number

var box2 = Number(&quot;08&quot;);
console.log(typeof box2);  //number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比较：&lt;br /&gt;
parseInt()——解析&lt;br /&gt;
Number()——简单转换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(Number(&quot;012xx&quot;)); //NaN
console.log(Number(&quot;xx012&quot;)); //NaN
console.log(parseInt(&quot;012xx&quot;)); //12
console.log(parseInt(&quot;xx012&quot;)); //NaN,如果第一个不是数值，就返回NaN
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 25 Nov 2013 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2013/11/25/jsPatternNote_1/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2013/11/25/jsPatternNote_1/</guid>
        
        <category>js模式笔记</category>
        
        
      </item>
    
      <item>
        <title>javascript基础三：this</title>
        <description>&lt;style type=&quot;text/css&quot;&gt;
	p{
		margin: 30px 0 5px 0;
	}
	img{
		margin-top: 5px !important;
	}
	.post-container h1, .post-container h2, .post-container h3, .post-container h4, .post-container h5, .post-container h6 {
    	margin: 60px 0 10px;
	}
	.post-container ul, .post-container ol {
	    margin-bottom: 20px;
	}
&lt;/style&gt;

&lt;p&gt;在JAVA，C，C#，C++等语言中，this很专一，总是指向当前的运行对象。&lt;br /&gt;
但是javascript的this却很花心，在哪个对象的家里，它就是那个对象的！&lt;/p&gt;

&lt;p&gt;请牢牢记住这句话：&lt;br /&gt;
&lt;strong&gt;this变量永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。如果处在匿名函数中或者不处于任何对象中，this都指向宿主的根对象（在浏览器里面就是 window）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外，javascript中还用 &lt;code&gt;call()&lt;/code&gt; 和 &lt;code&gt;apply()&lt;/code&gt; 来调用函数，再记住下面这两句话：&lt;br /&gt;
&lt;strong&gt;如果是call()、apply()、with()，指定的this是谁，就是谁。&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;普通的函数调用，函数被谁调用，this就是谁。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意：ECMAScript 5 的严格模式中，严禁使用with()函数，并且ECMAScript 3 中并不推荐使用with()。&lt;/p&gt;

&lt;p&gt;下面介绍下js函数的几种调用形式：&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1.纯粹的函数调用&lt;/h3&gt;

&lt;p&gt;这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 1;

function test(){
    console.log(this);    // window 证明this就是全局对象
    console.log(this.x);  // 1
    this.x = 0;           // 改变window.x，此时若window没有变量x，则在window下创建一个x变量
    console.log(this.x);  // 0
}

console.log(this.x);     // 1
test();
console.log(this.x);     // 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下情况会意外创建全局变量，要避免&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function makeNoSense(x) {
     this.x = x;     // this被绑定到全局对象
}
makeNoSense(5);
console.log(x);      // x已经成为一个值为5的全局变量
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2.作为对象方法的调用&lt;/h3&gt;
&lt;p&gt;函数还可以作为某个对象的方法调用，这时this就指这个上级对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function test(){
    console.log(this.x);  //this指函数的调用者
}
var o = {
    x: 1,
    m: test
};
test();  //undefined
o.m();   //1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;var obj = {
    that: this,
    fn: function(){
        console.log(this);
    }
}
console.log(obj.that); //window, this不存在Object对象中的时候,this就指向window全局对象
obj.fn();              //obj, this指向调用其所在函数的对象
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3.作为构造函数调用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var x = 2;
function test(){
    this.x = 1;
}

var o = new test();  // 没有改变global的x
console.log(o.x);    // 1
console.log(x);      // 2

test();              // 改变了global的x
console.log(o.x);    // 1
console.log(x);      // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;apply&quot;&gt;4.apply调用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var x = 2;
function test(){
    console.log(this.x);
}

var o = {};
o.x = 1;
o.m = test;

o.m();          //1
o.m.apply();    //2  参数为空时，默认调用全局对象
o.m.apply(o);   //1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;function changeStyle(type, value){
    this.style[type] = value;
}
var one = document.getElementById( &#39;one&#39; );
changeStyle.call(one, &#39;fontSize&#39;, &#39;100px&#39;);
changeStyle.apply(one, [&#39;fontSize&#39;, &#39;100px&#39;]);
changeStyle(&#39;fontSize&#39; , &#39;300px&#39;);  //出现错误，因为此时changeStyle中this引用的是window对象，而window并无style属性。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;私有属性和方法、特权属性和方法、共有属性和方法、共有静态属性和方法&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;私有属性和方法&lt;/strong&gt;：函数有作用域,在函数内用&lt;code&gt;var&lt;/code&gt;关键字声明的变量在外部无法访问, 私有属性和方法本质就是你希望在对象外部无法访问的变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特权属性和方法&lt;/strong&gt;：创建属性和方法时使用的&lt;code&gt;this&lt;/code&gt;关键字,因为这些方法定义在构造器的作用域中,所以它们可以访问到私有属性和方法; 只有那些需要直接访问私有成员的方法才应该被设计为特权方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;共有属性和方法&lt;/strong&gt;：直接链在&lt;code&gt;prototype&lt;/code&gt;上的属性和方法,不可以访问构造器内的私有成员,可以访问特权成员,子类会继承所有的共有方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;共有静态属性和方法&lt;/strong&gt;：最好的理解方式就是把它想象成一个命名空间,实际上相当于把构造器作为命名空间来使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var _packaging= function (){
    //私有属性和方法
    var name= &#39;Darren&#39;;
    var method1= function(){...}

    //特权属性和方法
    this.title= &#39;JavaScript Design Patterns&#39; ;
    this.getName= function(){return name;}
 }

 //共有静态属性和方法
 _packaging._name= &#39;Darren code&#39;;
 _packaging.alertName= function (){
    alert(_packaging._name);
 }

 //共有属性和方法
 _packaging.prototype= {
    init:function (){...}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小栗子1：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//全局变量
name = &quot;xuxuan&quot;;

var Pet = function(){

    //私有属性和方法
    var name = &quot;xxx&quot;;
    function showname(){
        console.log(&quot;2 &quot;+this.name); // 这里的this-&amp;gt;window &#39;xuxuan&#39;
        console.log(&quot;3 &quot;+name);      // &#39;xxx&#39;
    }

    //特权属性和方法
    this.name = &quot;xx&quot;;
    this.show = function(){
        console.log(&quot;1 &quot;+this.name); // 这里的this-&amp;gt;pet  &#39;xx&#39;
        showname();
        console.log(&quot;4 &quot;+name);      // &#39;xxx&#39;
    }
}

var cat = new Pet();
console.log(&quot;0 &quot;+cat.name); //xx
cat.show();

/*
输出如下：
0 xx
1 xx
2 xuxuan
3 xxx
4 xxx
*/

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;私有方法的this分两种情况，单独调用的指向window，有调用者的指向调用者&lt;br /&gt;
特权方法的this指向当前实例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;小栗子2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//全局变量
name = &quot;xuxuan&quot;;

var Pet = function(){

    //私有属性和方法
    var name = &quot;xxx&quot;;
    function showname(){
        console.log(this.name); // 这里的this-&amp;gt;window &#39;xuxuan&#39;
    }

    //特权属性和方法
    this.name = &quot;xx&quot;;
    this.show = function(){
        console.log(this.name); // 这里的this-&amp;gt;pet  &#39;xx&#39;
        showname();
    }
}

Pet.prototype.setnamePet = function(str){   // 共有方法,可以访问特权成员
    this.name = str;   // 这里的name-&amp;gt;特权属性name
}

Pet.prototype.setnameGlobal = function(str){ // 共有方法
    name = str;        // 这里的name-&amp;gt;全局变量name
}

var cat = new Pet();
console.log(cat.name); //xx
cat.show();   //xx xuxuan

cat.setnamePet(&quot;Penguin1&quot;);
cat.show();   //Penguin1 xuxuan
cat.setnamePet(&quot;wind1&quot;);
cat.show();   //wind1 xuxuan

cat.setnameGlobal(&quot;Penguin2&quot;);
cat.show();   //wind1 Penguin2
cat.setnameGlobal(&quot;wind2&quot;);
cat.show();   //wind1 wind2
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;特权方法可以访问私有属性和方法&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Mon, 07 Oct 2013 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2013/10/07/jsBasic03/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2013/10/07/jsBasic03/</guid>
        
        <category>js基础</category>
        
        
      </item>
    
      <item>
        <title>javascript基础二：javascript创建对象</title>
        <description>&lt;style type=&quot;text/css&quot;&gt;
    p{
        margin: 30px 0 5px 0;
    }
    img{
        margin-top: 5px !important;
    }
    .post-container h1, .post-container h2, .post-container h3, .post-container h4, .post-container h5, .post-container h6 {
        margin: 60px 0 10px;
    }
    .post-container ul, .post-container ol {
        margin-bottom: 20px;
    }
&lt;/style&gt;

&lt;h2 id=&quot;section&quot;&gt;1.创建对象&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var person = new Object();
person.name = &#39;kathy&#39;;
person.age = 25;
person.job = &#39;frontend&#39;;
person.sayName = function(){
    alert(this.name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br /&gt;
使用同一个接口创建很多对象，会产生大量重复代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2.工厂模式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function createPerson(name,age,job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    }
    return o;
}
var p1 = createPerson(&#39;kathy&#39;,25,&#39;frontend&#39;);
var p2 = createPerson(&#39;jack&#39;,24,&#39;backend&#39;);
p1.sayName(); //&#39;kathy&#39;
p2.sayName(); //&#39;jack&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;用函数来封装以特定接口创建对象的细节&lt;br /&gt;
&lt;strong&gt;优点：&lt;/strong&gt;&lt;br /&gt;
解决了创建多个相似对象的问题&lt;br /&gt;
&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br /&gt;
没有解决对象识别的问题（怎样知道一个对象的类型）&lt;br /&gt;
不能用new&lt;br /&gt;
函数重复定义 （p1.sayName == p2.sayName）  false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-2&quot;&gt;3.构造函数模式：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
        alert(this.name);
    };
}
var p1 = new Person(&#39;kathy&#39;,25,&#39;frontend&#39;);
var p2 = new Person(&#39;jack&#39;,24,&#39;backend&#39;);
p1.sayName(); //&#39;kathy&#39;
p2.sayName(); //&#39;jack&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;区别工厂模式：&lt;/strong&gt;&lt;br /&gt;
1、没有显式的创建对象&lt;br /&gt;
2、直接将属性和方法赋给了this对象&lt;br /&gt;
3、没有return语句&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;创建Person的新实例4步骤：&lt;/strong&gt;&lt;br /&gt;
1、创建一个新的对象&lt;br /&gt;
2、将构造函数的作用域赋给新对象（this指针就指向了这个新对象）&lt;br /&gt;
3、执行构造函数中的代码（为这个新对象添加属性）&lt;br /&gt;
4、返回新对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-3&quot;&gt;3.1对象识别问题&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;function Func() {};      // 定义一个空函数
var obj1 = new Func();   // 使用new操作符，借助Func函数，创建了一个对象
var obj2 = new Func;     // 函数也可以没有括号，但仍将调用该函数
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;js的语法可真是飘逸，该如何理解呢？&lt;br /&gt;
其实，上面的写法可以写成以下等价形式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Func() {}; 
var obj = {};
Func.call(obj);   // 将obj对象作为this指针调用Func函数
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;br /&gt;
解决了对象识别问题，可以将它的实例表示为一种特定的类型。&lt;br /&gt;
&lt;code&gt;alert(p1.constructor == Person);  //true&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(p2.constructor == Person);  //true&lt;/code&gt;&lt;br /&gt;
p1和p2分别保存着Person的一个不同的实例，都有一个constructor属性，指向Person&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;对象的&lt;strong&gt;constructor&lt;/strong&gt;属性最初是用来表示对象类型的。&lt;br /&gt;
对于检测对象类型，还是&lt;strong&gt;instanceof&lt;/strong&gt;可靠些，&lt;br /&gt;
&lt;code&gt;alert(p1 instanceof Object);  //true&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(p1 instanceof Person);  //true&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(p2 instanceof Object);  //true&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(p2 instanceof Person);  //true&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-4&quot;&gt;3.2构造函数的三种调用方式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;//当做构造函数使用，构造函数与其他函数唯一区别：调用方式不同，用new
var person = new Person(&#39;kathy&#39;,25,&#39;student&#39;);
person.sayName();

//作为普通函数调用
Person(&#39;Jack&#39;,30,&#39;doctor&#39;);
window.sayName();

//在另一个对象的作用域中调用
var o = new Object();
Person.call(o,&#39;Cate&#39;,27,&#39;nurse&#39;);
o.sayName();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;当在全局作用域中调用一个函数，this对象总是指向Global对象（在浏览器中就是window对象）&lt;br /&gt;
可以使用call(),apply()在某个特殊对象的作用域中调用Person()函数。这里是在o的作用域中调用的，调用后o就拥有了所有属性和sayName()方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-5&quot;&gt;3.3构造函数的问题&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// 函数是对象，每定义一个函数，也就是实例化了一个对象。
function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = new Function(&quot; alert(this.name)&quot;); //与申明函数在逻辑上是等价的
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br /&gt;
每个方法都要在每个实例上重新创建一遍，p1和p2都有一个名为sayName()的方法，但是不是同一个Function的实例，却拥有同样的功能。&lt;br /&gt;
&lt;code&gt;alert(p1.sayName() == p2.sayName()); //false&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;br /&gt;
把函数定义移到构造函数外部：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName;
}

function sayName(){
    alert(this.name);
}

var p1 = new Person(&#39;kathy&#39;,25,&#39;student&#39;)
var p2 = new Person(&#39;cgg&#39;,24,&#39;programmer&#39;);

p1.sayName();
p2.sayName();
alert(p1.constructor == Person);  //true
alert(p2.constructor == Person);  //true
alert(p1 instanceof Object);  //true
alert(p1 instanceof Person);  //true
alert(p2 instanceof Object);  //true
alert(p2 instanceof Person);  //true
alert(p1.sayName == p2.sayName);  //true
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;p1和p2对象共享在全局作用域中定义的一个sayName()函数。&lt;br /&gt;
&lt;strong&gt;问题：&lt;/strong&gt;&lt;br /&gt;
让全局作用域有点名不副实，&lt;br /&gt;
如果对象需要定义多个方法，就要定义多个全局函数，那么这个自定义的应用类型就毫无封装性可言了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-6&quot;&gt;4.原型模式&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;原型好处：可以让所有对象实例共享它所包含的属性和方法，&lt;br /&gt;
不必再构造函数中定义对象信息，可以直接添加到原型对象中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}

Person.prototype.name = &#39;kathy&#39;;
Person.prototype.age = 25;
Person.prototype.job = &#39;student&#39;;
Person.prototype.sayName = function(){
    alert(this.name);
};

var p1 = new Person();
p1.sayName();  //&#39;kathy&#39;

var p2 = new Person();
p2.sayName();  //&#39;kathy&#39;

alert(p1.sayName == p2.sayName);  //true
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;将Person的所有属性都直接添加到Person的prototype属性中，构造函数变成了空函数。&lt;br /&gt;
仍可调用构造函数创建一个新对象，新对象还会具有相同的属性和方法，p1和p2访问的是同一组属性和同一个sayName()函数；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-7&quot;&gt;4.1理解原型：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;../../../../imgPost/2013-09-10/p1.png&quot; alt=&quot;&amp;quot;理解原型&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一旦创建函数，就为该函数创建一个prototype属性。&lt;br /&gt;
默认情况，所有prototype属性自动获得一个constructor属性，至于其他方法，都是从Object继承而来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Person.prototype 指向原型对象&lt;/li&gt;
  &lt;li&gt;Person.prototype.constructor 又指回Person&lt;/li&gt;
  &lt;li&gt;Person的实例person1,person2包含一个内部属性&lt;code&gt;_proto_&lt;/code&gt;，指向Person.prototype，他们与构造函数没有直接的关系&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这两个实例都不包含属性和方法，但我们却可以调用person1.sayName()，是通过查找对象属性的过程来实现的。&lt;br /&gt;
查找顺序：&lt;strong&gt;先对象本身，后原型属性&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}

Person.prototype.name = &#39;kathy&#39;;
Person.prototype.age = 25;
Person.prototype.job = &#39;frontend&#39;;
Person.prototype.sayName = function(){
    alert(this.name);
}

var p1 = new Person();
var p2 = new Person();

p1.name = &#39;xuxuan&#39;;
alert(p1.name); //&#39;xuxuan&#39;
alert(p2.name); //&#39;kathy&#39;

p1.name = null;
alert(p1.name); // null

delete p1.name;
alert(p1.name); // &#39;kathy&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;当为对象实例添加一个属性时，会屏蔽原型对象中同名属性，添加的这个属性会阻止我们访问原型中的那个属性，但不会修改那个值。&lt;br /&gt;
即使将这个属性设置为&lt;code&gt;null&lt;/code&gt;，也只会在实例中设置这个属性，不会恢复其指向原型的链接。&lt;br /&gt;
不过可以通过&lt;code&gt;delete&lt;/code&gt;操作符完成删除实例的属性，从而能重新访问原型中的属性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;isprototypeofhasownpropertyin&quot;&gt;4.2 isPrototypeOf、hasOwnProperty、in属性&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}

Person.prototype.name = &#39;kathy&#39;;
Person.prototype.age = 25;
Person.prototype.job = &#39;student&#39;;
Person.prototype.sayName = function(){
    alert(this.name);
}

var p1 = new Person();
var p2 = new Person();

alert(Person.prototype.isPrototypeOf(p1));  //true
alert(Person.prototype.isPrototypeOf(p2));  //true

alert(p1.hasOwnProperty(&#39;name&#39;));  //fasle
p1.name = &#39;xuxuan&#39;
alert(p1.name);  //&#39;xuxuan&#39;
alert(p1.hasOwnProperty(&#39;name&#39;));  //true

alert(p2.name);  //&#39;kathy&#39;
alert(p2.hasOwnProperty(&#39;name&#39;));  //false

delete p1.name;
alert(p1.name);  //&#39;kathy&#39;
alert(p1.hasOwnProperty(&#39;name&#39;));  //false
alert(&#39;name&#39; in p1);  //true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上段代码图解如下：&lt;br /&gt;
&lt;img src=&quot;../../../../imgPost/2013-09-10/p2.png&quot; alt=&quot;&amp;quot;理解原型&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结如下：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;isPrototypeOf&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;obj1.isPrototypeOf(obj2);&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;用来判断指定对象obj1是否存在于另一个对象obj2的原型链中，是则返回true，否则返回false。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hasOwnProperty&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;obj.hasOwnProperty(&#39;name&#39;);&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;只检测&lt;strong&gt;对象本身的属性&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;in&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;&#39;name&#39; in obj&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;检测&lt;strong&gt;对象本身的属性&lt;/strong&gt;或&lt;strong&gt;原型链的属性&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hasPrototypeProperty(自定义方法)&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;hasPrototypeProperty(obj,&#39;name&#39;)&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;‘name’属性只存在于&lt;strong&gt;原型链的属性&lt;/strong&gt;，而不存在于对象本身的属性&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;function hasPrototypeProperty(object,name){
    return !object.hasOwnProperty(name) &amp;amp;&amp;amp; (name in object);
}

function Person(){}

Person.prototype.name = &#39;kathy&#39;;
Person.prototype.age = 25;
Person.prototype.job = &#39;student&#39;;
Person.prototype.sayName = function(){
     alert(this.name);
}

var p = new Person();
alert(hasPrototypeProperty(p,&#39;name&#39;)); //true

p.name = &#39;xuxuan&#39;;
alert(hasPrototypeProperty(p,&#39;name&#39;)); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-8&quot;&gt;4.3更简单的原型语法&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}

Person.prototype = {
    name : &#39;kathy&#39;,
    age : 25 ,
    job : &#39;student&#39;,
    sayName : function(){
        alert(this.name);
    }
};

var person = new Person();
alert(person instanceof Object); //true
alert(person instanceof Person); //true
alert(person.constructor == Object); //true
alert(person.constructor == Person); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;为了从视觉上更好的封装原型，用一个包含所有属性和方法的对象字面量来重写整个原型对象；&lt;br /&gt;
每创建一个函数，同时也会创建它的prototype对象，其会自动获得constructor属性；&lt;br /&gt;
&lt;code&gt;Person.prototype = {...};&lt;/code&gt;本质上重写了默认的prototype属性，constructor属性不再指向Person，而指向Object函数。&lt;br /&gt;
如果写成&lt;code&gt;Person.prototype.name=&quot;kathy&quot;;...&lt;/code&gt;，constructor还是Person；&lt;br /&gt;
如果&lt;code&gt;var person = new Person();&lt;/code&gt; 写在&lt;code&gt;Person.prototype = {...}&lt;/code&gt;之前，这个对象的constructor还是Person;&lt;br /&gt;
尽管instanceof还能返回正确结果，但是通过constructor无法确定对象类型；&lt;br /&gt;
如果constructor的值真的很重要，可以特意将它设置回适当的值：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Person.prototype = {
     constructor : Person,
     name : &#39;kathy&#39;,
     ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-9&quot;&gt;4.4原型的动态性&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}
var person = new Person();
Person.prototype.sayHi = function(){
     alert(&quot;hi&quot;);
}
person.sayHi(); //hi
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;在原型中查找值得过程是一次搜索，因此对原型做的任何修改能立刻从实例中反映出来（先创建实例，后修改原型也如此）；&lt;br /&gt;
&lt;strong&gt;原因：&lt;/strong&gt; 实例与原型的松散链接关系，调用person.sayHi()时，先在实例中搜sayHi属性，没有，搜原型；实例与原型之间连接是一个&lt;strong&gt;指针&lt;/strong&gt;，而非一个副本，就可以在原型中找到sayHi属性并返回。&lt;br /&gt;
&lt;strong&gt;注意：&lt;/strong&gt; 如果重写整个原型对象，情况就不一样了。因为调用构造函数会为实例添加一个指向最初原型的&lt;code&gt;_proto_&lt;/code&gt;指针，而把原型修改为另外一个对象，就等于切断了构造函数与最初原型之间的联系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;../../../../imgPost/2013-09-10/p3.png&quot; alt=&quot;&amp;quot;理解原型&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可看出：重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../imgPost/2013-09-10/p4.png&quot; alt=&quot;&amp;quot;理解原型&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;4.5原型对象的问题&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、省略了为构造函数传递初始化参数这一环节，所有实例默认情况下取得相同的属性值，一定不便&lt;br /&gt;
2、共享，对函数非常适合；包含基本值的属性，也还好；引用类型的属性，问题突出&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Person(){}

Person.prototype = {
    constructor : Person,
    name : &#39;kathy&#39;,
    age : 25 ,
    job : &#39;student&#39;,
    sayName : function(){
        alert(this.name);
    },
    friends:[&quot;Jack&quot;,&quot;Cate&quot;]
};

var person1 = new Person();
var person2 = new Person();
person1.friends.push(&quot;Van&quot;);

alert(person1.friends); //&#39;Jack,Cate,Van&#39;
alert(person2.friends); //&#39;Jack,Cate,Van&#39;
alert(person1.friends == person2.friends); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-11&quot;&gt;5.组合使用构造函数模式和原型模式&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = [&quot;Jack&quot;,&quot;Cate&quot;];
}

Person.prototype = {
    constructor : Person,
    sayName : function(){
        alert(this.name);
    }
};

var person1 = new Person(&#39;kathy&#39;,25,&#39;frontend&#39;);
var person2 = new Person(&#39;jack&#39;,24,&#39;backend&#39;);
person1.friends.push(&quot;Van&quot;);

alert(person1.friends); //&#39;Jack,Cate,Van&#39;
alert(person2.friends); //&#39;Jack,Cate&#39;
alert(person1.friends == person2.friends); //false
alert(person1.sayName == person2.sayName); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;构造函数 –&amp;gt; 定义实例属性&lt;br /&gt;
原型模式 –&amp;gt; 定义方法和共享的属性&lt;br /&gt;
&lt;strong&gt;优点：&lt;/strong&gt; 节省内存，向构造函数传参&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-12&quot;&gt;6.动态原型模式：&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function Person(name,age,job){
    this.name = name;
    this.age = age;
    this.job = job;

    if(typeof this.sayName != &#39;function&#39;){
        //只在sayName方法不存在时，才添加到原型中；只会在初次调用构造函数才执行，此后原型已完成初始化
        Person.prototype.sayName = function(){
            alert(this.name);
        };
    }
}

var person = new Person(&#39;kathy&#39;,25,&#39;student&#39;);
person.sayName();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;把所有信息封装在了构造函数中&lt;br /&gt;
&lt;strong&gt;优点：&lt;/strong&gt; 在构造函数中初始化原型，又保持了同时使用构造函数和原型的优点；通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型；&lt;br /&gt;
&lt;strong&gt;注意：&lt;/strong&gt; 不能使用对象字面量重写原型，如果在创建了实例的情况下，会切断所有现有实例与新原型之间的联系；&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 10 Sep 2013 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2013/09/10/jsBasic02/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2013/09/10/jsBasic02/</guid>
        
        <category>js基础</category>
        
        
      </item>
    
      <item>
        <title>javascript基础一：六大基本数据类型Undefined、Null、Boolean、Number、String、Object</title>
        <description>&lt;style type=&quot;text/css&quot;&gt;
	p{
		margin: 30px 0 5px 0;
	}
	img{
		margin-top: 5px !important;
	}
&lt;/style&gt;

&lt;p&gt;&lt;strong&gt;5种简单数据类型：&lt;/strong&gt; Undefined、Null、Boolean、Number 和 String&lt;br /&gt;
&lt;strong&gt;1种复杂数据类型：&lt;/strong&gt; Object&lt;br /&gt;
&lt;strong&gt;typeof&lt;/strong&gt; 返回的是字符串，有六种可能：&lt;br /&gt;
“undefined”、”boolean”、”number”、”string”、”object”、”function”&lt;/p&gt;

&lt;h2 id=&quot;undefined-vs-null-vs-nan&quot;&gt;undefined vs null vs NaN&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var a1;
var a2 = true;
var a3 = 1;
var a4 = &quot;Hello&quot;;
var a5 = new Object();
var a6 = null;
var a7 = NaN;
var a8 = undefined;
alert(typeof a);  //显示&quot;undefined&quot;
alert(typeof a1); //显示&quot;undefined&quot;
alert(typeof a2); //显示&quot;boolean&quot;
alert(typeof a3); //显示&quot;number&quot;
alert(typeof a4); //显示&quot;string&quot;
alert(typeof a5); //显示&quot;object&quot;
alert(typeof a6); //显示&quot;object&quot;
alert(typeof a7); //显示&quot;number&quot;
alert(typeof a8); //显示&quot;undefined&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;从上面的代码中可以看出:&lt;br /&gt;
1. 未定义的值和定义未赋值的为undefined&lt;br /&gt;
2. null是一种特殊的object&lt;br /&gt;
3. NaN是一种特殊的number&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;// 空的对象，表示这个对象创建了，里面没有东西
// var box = {};
var box = new Object();   // box是Object类型，值是[object,Object]，类型返回的字符串是object
alert(box);               // [object,Object]
alert(typeof box);        // &quot;object&quot;

//空对象，表示没有创建，就是一个null
var box = null;          // box是Null类型，值是null，类型返回的字符串是object
alert(box);              // null
alert(typeof box);       // &quot;object&quot;

var box = function(){ var a = 20;}
alert(box);              // function(){ var a = 20;}
alert(typeof  box);      // &quot;function&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：函数在ECMAScript 中是对象，不是一种数据类型。&lt;br /&gt;
所以，使用typeof 来区分function 和object 是非常有必要的!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var box;
alert(box);     // undefined
alert(cat);     // Uncaught ReferenceError: cat is not defined 浏览器报错
alert(typeof box);     // &quot;undefined&quot;
alert(typeof cat);     // &quot;undefined&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;变量&lt;/td&gt;
      &lt;td&gt;描述&lt;/td&gt;
      &lt;td&gt;值&lt;/td&gt;
      &lt;td&gt;类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;box&lt;/td&gt;
      &lt;td&gt;未初始化的变量&lt;/td&gt;
      &lt;td&gt;“undefined”&lt;/td&gt;
      &lt;td&gt;undefined&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cat&lt;/td&gt;
      &lt;td&gt;根本不存在的变量(未声明的变量)&lt;/td&gt;
      &lt;td&gt;报错&lt;/td&gt;
      &lt;td&gt;undefined&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Undefined&lt;/strong&gt; 类型只有一个值，即特殊的”undefined”。在使用var声明变量，但没有对其初始化时，这个变量的值就是undefined。无法使用 for/in 循环来枚举 undefined 属性，也不能用 delete 运算符来删除它。undefined 不是常量，可以把它设置为其他值。&lt;br /&gt;
&lt;strong&gt;Null&lt;/strong&gt; 类型是一个只有一个值，即特殊的值”null”。它表示一个空对象引用(指针)，而typeof操作符检测null会返回object。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box;
var car = null;
alert(box == car)  // true
alert(typeof box == typeof car)  // false
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;有个要说明的是：undefined 是派生自null 的，因此ECMA-262 规定对它们的相等性测试返回true。&lt;br /&gt;
&lt;code&gt;alert(undefined == null);   //true值相等&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(undefined === null); //false值相等，数据类型不等&lt;/code&gt;&lt;br /&gt;
由于undefined 和null 两个值的比较是相等的，所以，未初始化的变量和赋值为null 的变量会相等。&lt;br /&gt;
这时，可以采用typeof 变量的类型进行比较。但，建议还是养成编码的规范，不要忘记初始化变量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var a1;         //a1的值为undefined
var a2 = null;
var a3 = NaN;
alert(a1 == a2); //显示&quot;true&quot;
alert(a1 != a2); //显示&quot;false&quot;
alert(a1 == a3); //显示&quot;false&quot;
alert(a1 != a3); //显示&quot;true&quot;
alert(a2 == a3); //显示&quot;false&quot;
alert(a2 != a3); //显示&quot;true&quot;
alert(a3 == a3); //显示&quot;false&quot;
alert(a3 != a3); //显示&quot;true&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;从上面的例子可以得出结论：&lt;br /&gt;
1.undefined与null是相等；&lt;br /&gt;
2.NaN与任何值都不相等，与自己也不相等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;boolean&quot;&gt;Boolean&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var box = true;
alert(box == 1); //true
alert(box === 1); //false
alert(typeof box == typeof 1); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;强制性转——要将一个值转换为其对应的Boolean 值，可以使用转型函数Boolean()&lt;br /&gt;
隐式转换——if 条件语句里面的条件判断&lt;/p&gt;

&lt;p&gt;以下是其他类型转换成Boolean类型规则：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;数据类型&lt;/td&gt;
      &lt;td&gt;转换为true的值&lt;/td&gt;
      &lt;td&gt;转换为false的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;非空字符串&lt;/td&gt;
      &lt;td&gt;空字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;任何非0数值（包括无穷大）&lt;/td&gt;
      &lt;td&gt;0 和 NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Object&lt;/td&gt;
      &lt;td&gt;任何对象&lt;/td&gt;
      &lt;td&gt;null&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Undefined&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;undefined&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;number&quot;&gt;Number&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;var box = 070;   //八进制
alert(box);      //56  -- 输出都是十进制！！！

var box = 079;
alert(box);      //无效的八进制，自动解析为79

浮点类型
var box = 03.8;
alert(box);      //error
var box = 3.80;
alert(box);      //3.8
var box = .8     //0.8 有效，但不推荐此写法

//由于保存浮点数值需要的内存空间比整型数值大两倍，因此ECMAScript 会自动将可以转换为整型的浮点数值转成为整型。
var box = 8.;   //小数点后面没有值，转换为8
var box = 12.0; //小数点后面是0，转成为12
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;alert(Number.MIN_VALUE); //最小值 5e-324
alert(Number.MAX_VALUE); //最大值 1.7976931348623157e+308

var box1 = 100e1000; //超出范围，Infinity
var box2 = -100e1000; //超出范围，-Infinity
alert(box1);   // Infinity
alert(box2);   // -Infinity

alert(Number.POSITIVE_INFINITY); //Infinity(正无穷)
alert(Number.NEGATIVE_INFINITY); //-Infinity(负无穷)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;isFinite()&lt;/code&gt;函数。如果没有超过，返回true，超过了返回false。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = 100e1000;
alert(isFinite(box));  // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NaN&lt;/code&gt;，即非数值(Not a Number)是一个特殊的值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = 0 / 0; //NaN
var box = 12 / 0; //Infinity
var box = 12 / 0 * 0; //NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过&lt;code&gt;Number.NaN&lt;/code&gt; 得到NaN 值，任何与NaN 进行运算的结果均为NaN，NaN 与自身不相等(NaN 不与任何值相等)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(Number.NaN); //NaN
alert(NaN+1); //NaN
alert(NaN == NaN) //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ECMAScript 提供了&lt;code&gt;isNaN()&lt;/code&gt;函数，用来判断这个值到底是不是NaN。isNaN()函数在接收到一个值之后，会尝试将这个值转换为数值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(isNaN(NaN)); //true
alert(isNaN(25)); //false，25 是一个数值
alert(isNaN(&#39;25&#39;)); //false，&#39;25&#39;是一个字符串数值，可以转成数值
alert(isNaN(&#39;Lee&#39;)); //true，&#39;Lee&#39;不能转换为数值
alert(isNaN(true)); //false， true可以转成成1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;isNaN()&lt;/code&gt;函数也适用于对象。在调用isNaN()函数过程中，首先会调用valueOf()方法，然后确定返回值是否能够转换成数值。如果不能，则基于这个返回值再调用toString()方法，再测试返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = {
    toString : function () {
        return &#39;123&#39;; //可以改成return &#39;Lee&#39;查看效果
    }
};
alert(isNaN(box)); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section&quot;&gt;非数值转换为数值&lt;/h4&gt;

&lt;p&gt;有3 个函数可以把非数值转换为数值：&lt;code&gt;Number()&lt;/code&gt;、&lt;code&gt;parseInt()&lt;/code&gt;和&lt;code&gt;parseFloat()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Number()&lt;/code&gt;函数是转型函数，可以用于任何数据类型，而另外两个则专门用于把字符串转成数值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(Number(true)); //1，Boolean 类型的true 和false 分别转换成1 和0
alert(Number(25)); //25，数值型直接返回
alert(Number(null)); //0，空对象返回0
alert(Number(undefined)); //NaN，undefined 返回NaN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是字符串，应该遵循以下规则：&lt;br /&gt;
1.只包含数值的字符串，会直接转成成十进制数值，如果包含前导0，即自动去掉。&lt;br /&gt;
&lt;code&gt;alert(Number(&#39;456&#39;)); //456&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;alert(Number(&#39;070&#39;)); //70&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.只包含浮点数值的字符串，会直接转成浮点数值，如果包含前导和后导0，即自动去掉。&lt;br /&gt;
&lt;code&gt;alert(Number(&#39;08.90&#39;)); //8.9&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.如果字符串是空，那么直接转成成0。&lt;br /&gt;
&lt;code&gt;alert(Number(&#39;&#39;)); //0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4.如果不是以上三种字符串类型，则返回NaN。&lt;br /&gt;
&lt;code&gt;alert(Number(&#39;Lee123&#39;)); //NaN&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;5.如果是对象，首先会调用valueOf()方法，然后确定返回值是否能够转换成数值。如果&lt;br /&gt;
转换的结果是NaN，则基于这个返回值再调用toString()方法，再测试返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = {
    toString : function () {
        return &#39;123&#39;; //可以改成return &#39;Lee&#39;查看效果
    }
};
alert(Number(box)); //123
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于&lt;code&gt;Number()&lt;/code&gt;函数在转换字符串时比较复杂且不够合理，因此在处理整数的时候更常用的是&lt;code&gt;parseInt()&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alert(parsetInt(&#39;456Lee&#39;)); //456，会返回整数部分
alert(parsetInt(&#39;Lee456Lee&#39;)); //NaN，如果第一个不是数值，就返回NaN
alert(parseInt(&#39;12Lee56Lee&#39;)); //12，从第一数值开始取，到最后一个连续数值结束
alert(parseInt(&#39;56.12&#39;)); //56，小数点不是数值，会被去掉
alert(parseInt(&#39;&#39;)); //NaN，空返回NaN

//parseInt()除了能够识别十进制数值，也可以识别八进制和十六进制。
alert(parseInt(&#39;0xA&#39;)); //10，十六进制
alert(parseInt(&#39;070&#39;)); //56，八进制
alert(parseInt(&#39;0xALee&#39;)); //100，十六进制，Lee 被自动过滤掉

//ECMAScript 为parseInt()提供了第二个参数，用于解决各种进制的转换。
alert(parseInt(&#39;0xAF&#39;)); //175，十六进制
alert(parseInt(&#39;AF&#39;,16)); //175，第二参数指定十六进制，可以去掉0x 前导
alert(parseInt(&#39;AF&#39;)); //NaN，理所当然
alert(parseInt(&#39;101010101&#39;,2)); //314，二进制转换
alert(parseInt(&#39;70&#39;,8)) //56，八进制转换

//parseFloat()是用于浮点数值转换的，和parseInt()一样，从第一位解析到非浮点数值位置。
alert(parseFloat(&#39;123Lee&#39;)); //123，去掉不是别的部分
alert(parseFloat(&#39;0xA&#39;)); //0，不认十六进制
alert(parseFloat(&#39;123.4.5&#39;)); //123.4，只认一个小数点
alert(parseFloat(&#39;0123.400&#39;)); //123.4，去掉前后导
alert(parseFloat(&#39;1.234e7&#39;)); //12340000，把科学技术法转成普通数值
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;string&quot;&gt;String&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;字面量&lt;/td&gt;
      &lt;td&gt;含义&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\n&lt;/td&gt;
      &lt;td&gt;换行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\t&lt;/td&gt;
      &lt;td&gt;制表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\b&lt;/td&gt;
      &lt;td&gt;空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\r&lt;/td&gt;
      &lt;td&gt;回车&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\f&lt;/td&gt;
      &lt;td&gt;换页&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\&lt;/td&gt;
      &lt;td&gt;斜杠&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&#39;&lt;/td&gt;
      &lt;td&gt;单引号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&quot;&lt;/td&gt;
      &lt;td&gt;双引号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\xnn&lt;/td&gt;
      &lt;td&gt;以十六进制代码nn表示的一个字符(0~F)。例：\x41&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\unnn&lt;/td&gt;
      &lt;td&gt;以十六进制代码nnn表示的一个Unicode字符(0~F)。例：\u01a9&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = &#39;Mr.&#39;;
box = box + &#39; Lee&#39;;   //把原来的‘Mr’复制一份，再加上‘Lee’，赋值给box，原来的‘Mr’销毁
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt;方法一般是不需要传参的，但在数值转成字符串的时候，可以传递进制参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = 10;
alert(box.toString()); //&#39;10&#39;，默认输出
alert(box.toString(2)); //&#39;1010&#39;，二进制输出
alert(box.toString(8)); //&#39;12&#39;，八进制输出
alert(box.toString(10)); //&#39;10&#39;，十进制输出
alert(box.toString(16)); //&#39;a&#39;，十六进制输出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在转型之前不知道变量是否是null 或者undefined 的情况下，我们还可以使用转型函数&lt;code&gt;String()&lt;/code&gt;，这个函数能够将任何类型的值转换为字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = null;
alert(String(box));//&#39;null&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;objec&quot;&gt;Objec&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var box = null;
var box = {};
var box = new Object();
var box = Object();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Object()里可以任意传参，可以传数值、字符串、布尔值等。而且，还可以进行相应的计算。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = new Object(2);  //Object 类型，值是2
alert(box);               //2
alert(typeof box);        //&quot;object&quot;
alert(box+2);             //4，可以和普通变量运算
alert(typeof (box+2));    //&quot;number&quot;，输出结果转型成Number类型了
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Number，String，Boolean用&lt;code&gt;new&lt;/code&gt;出来的是Object类型&lt;br /&gt;
数组和对象不用new也是object类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var box = new Number(22);
alert(typeof box);   //object

var cat = 22;
alert(typeof cat);     //number
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 03 Sep 2013 00:00:00 +0800</pubDate>
        <link>http://kathyxxu.github.io/2013/09/03/jsBasic01/</link>
        <guid isPermaLink="true">http://kathyxxu.github.io/2013/09/03/jsBasic01/</guid>
        
        <category>js基础</category>
        
        
      </item>
    
  </channel>
</rss>
